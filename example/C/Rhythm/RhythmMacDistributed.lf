/**
 * Demonstration of timed distributed Lingua Franca programs.
 * This program is not portable. It runs on MacOS.
 * 
 * This program elaborates RhythmMac to have two players that
 * run on different machines. Both players can select a musical
 * instrument, but only one of the players can control the rhythm
 * and the tempo.
 * 
 * @see RhythmMac.lf
 * @see RhythmMacDistributedIndependent.lf
 * @see RhythmMacDistributedNoUI.lf
 *
 * @author Edward A. Lee
 */
target C {
    coordination: centralized,
    flags: ["-lncurses", "-framework", "AudioToolbox", "-framework", "CoreFoundation", "-lm"],
    files: ["/lib/C/util/sensor_simulator.c", "/lib/C/util/sensor_simulator.h",
            "/lib/C/util/wave_file_reader.c", "/lib/C/util/wave_file_reader.h",
            "/lib/C/util/audio_loop_mac.c", "/lib/C/util/audio_loop.h",
            "/lib/C/util/audio_loop_linux.c",
            "sounds/Bass-Drum-1.wav", "sounds/Hi-Bongo.wav", "sounds/Claves.wav", "sounds/High-Conga-1.wav",
            "sounds/Cowbell-1.wav", "sounds/Cuica-1.wav", "sounds/Guiro.wav",
            "sounds/Ensoniq-ESQ-1-Snare.wav", "sounds/Floor-Tom-1.wav"]
};
 
import RhythmSource from "RhythmMac.lf"

preamble {=    
    //////////////////////////////////////
    // Configuration of the user interface.

    char* player_message[] = {
        "Effects:",
        "  m: mirror",
        "Instrument:",
        "  0: none",
        "  1: bass drum",
        "  2: bongo",
        "  3: claves",
        "  4: conga",
        "  5: cowbell",
        "  6: cuica",
        "  7: guiro",
        "  8: snare",
        "  9: tom"
    };
    int player_message_length = 13;
=}

/**
 * Reactor that outputs notes (which carry an emphasis))
 * according to rhythm given by an input. The minimum time
 * between notes is given by the most recently received
 * 'tempo' input.
 */
reactor Player(sixteenth:time(200 msec)) {    
    output note:float;         // To play a note with the given emphasis.
    output instrument:int;     // Instrument selection.
    input rhythm_change:char;  // To change the rhythm.
    input tempo:interval_t;    // To change the tempo.
    
    state tick_duration:time(200 msec);
    logical action tick;
    
    // Count of sixteenth notes.
    state count:int(0);
    
    // Action to be invoked when a key is pressed.
    physical action key:char;
    
    // Indicator of when to make a sound.
    state rhythm:int({=DOWNBEAT=});
    
    // Indicator of whether to emphasize the sound.
    state emphasis:int({=DOWNBEAT=});

   // Currently active rhythm. This becomes
    // active from rhythm on the downbeat.
    state active_rhythm:int({=DOWNBEAT=});
    
    // Currently active emphasis. This becomes
    // active from rhythm on the downbeat.
    state active_emphasis:int({=DOWNBEAT=});
        
    // Position of the cursor in the terminal window.
    state cursor:int(0);
    
    reaction(startup) -> key, note, tick {=
        // info_print("******* starting sensor simulator.");
        // Start the sensor simulator, which starts ncurses.
        if (start_sensor_simulator(player_message, player_message_length, 16)) {
            error_print_and_exit("ERROR: Failed to start sensor simulator.");
        }
        // info_print("******* started sensor simulator.");
        
        // Register action to trigger on key press.
        register_sensor_key('\0', key);
        
        schedule(tick, self->tick_duration);
    =}
	
    reaction(key) -> instrument {=
        // info_print("******* Player: reaction to key.");
        int numeric;
        switch (key->value) {
            case '0':
                SET(instrument, 0);
                break;
            default:
                numeric = (int)key->value;
                if (numeric >= 49 && numeric <= 57) {
                    // A digit between 1 and 9.
                    SET(instrument, numeric - 48);
                }
        }
    =}

    reaction(rhythm_change) {=
        // info_print("******* Player: reaction to rhythm_change.");
        switch (rhythm_change->value) {
            case 'm':
                self->rhythm = MERENGUE;
                self->emphasis = MERENGUE_EMPHASIS;
                SET(rhythm_change, 'm');
                break;
            case 'b':
                self->rhythm = BOSSA_NOVA;
                self->emphasis = BOSSA_NOVA_EMPHASIS;
                SET(rhythm_change, 'b');
                break;
            case 's':
                self->rhythm = SAMBA;
                self->emphasis = SAMBA_EMPHASIS;
                SET(rhythm_change, 's');
                break;
            default:
                self->rhythm = DOWNBEAT;
                self->emphasis = DOWNBEAT;
                SET(rhythm_change, 'd');
                break;
        }
    =}
    
    reaction(tempo) {=
        // info_print("******* Player: reaction to tempo.");
        self->tick_duration = tempo->value;
    =}
    
    // FIXME: Use inheritance to share this.
    // But we want its priority to be last!
    reaction(tick) -> note, tick {=
        // info_print("******* Player: reaction to tick.");
        int beeped = 0;
        int position = 0;
        position = 1 << self->count;
        if (position & self->active_rhythm) {
            double emphasis = 0.25;
            if (position & self->active_emphasis) {
                emphasis = 1.0;
            }
            SET(note, emphasis);
            beeped++;
        }
        if (beeped > 0) {
            if (position & self->active_emphasis) {
                show_tick("!");
            } else {
                show_tick("*");
            }
        } else {
            show_tick(".");
        }
        self->count++;
        if (self->count == 16) {
            self->active_rhythm = self->rhythm;
            self->active_emphasis = self->emphasis;
            self->count = 0;
        } 

        schedule(tick, self->tick_duration);
    =}
}

/**
 * Produce a note when a `note` input is received.
 * 
 * This reactor provides a small collection of built-in audio
 * waveforms which are read at startup time from .wav files.
 * The waveform input specifies which of the waveforms to play
 * upon the next `note` input received.
 * It is a number between 0 and NUM_WAVEFORMS. If a number outside
 * this range is received, then simple tick sounds will be produced.
 * Number 0 is specially interpreted for silence.
 *
 * The `note` input is a number, normally between 0.0 and 1.0,
 * that specifies the loudness of the note. If the loudness exceeds
 * 1.0, or if too many notes are played at once, clipping may occur.
 * 
 */
reactor PlayWaveform {
    input note:float;
    input waveform:int;
    
    /**
     * Index of the current waveform.
     * -1 means no waveform (just make ticks)).
     */
    state waveform_id:int(0);
        
    reaction(startup) {=
        
        // First waveform is empty.
        waveforms[0] = &empty_waveform;
        
        // Open and read waveform files.
        for (int i = 0; i < NUM_WAVEFORMS; i++) {
            waveforms[i + 1] = read_wave_file(waveform_files[i]);
        }
        
        // Start an audio loop that will become ready to receive
        // amplitude samples of audio data.
        lf_start_audio_loop(get_logical_time());
    =}
    
    reaction(waveform) {=
        // info_print("******* PlayWaveform: reaction to waveform.");
        self->waveform_id = waveform->value;
    =}
    
    reaction(note) {=
        // info_print("******* PlayWaveform: reaction to note.");
        if (self->waveform_id < 0 || self->waveform_id > NUM_WAVEFORMS) {
            lf_play_audio_waveform(NULL, note->value, get_logical_time());
        } else {
            lf_play_audio_waveform(waveforms[self->waveform_id], note->value, get_logical_time());
        }
    =} deadline (100 msec) {=  // NOTE: deadline has to match BUFFER_DURATION_NS.
        warning_print("Missed deadline!");
    =}
    
    reaction(shutdown) {=
        lf_stop_audio_loop();
    =}
}

reactor RhythmMacMaster {
    output rhythm_change:char;  // To change the rhythm.
    output tempo:interval_t;    // To change the tempo.
    source = new RhythmSource();
    play = new PlayWaveform();
    source.note -> play.note;
    source.instrument -> play.waveform;
    source.rhythm_change -> rhythm_change;
    source.tempo -> tempo;
}

reactor RhythmMacPlayer {
    input rhythm_change:char;  // To change the rhythm.
    input tempo:interval_t;    // To change the tempo.
    source = new Player();
    play = new PlayWaveform();
    source.note -> play.note;
    source.instrument -> play.waveform;
    rhythm_change -> source.rhythm_change;
    tempo -> source.tempo;
}

federated reactor {
    player1 = new RhythmMacMaster();
    player2 = new RhythmMacPlayer();
    player1.rhythm_change -> player2.rhythm_change after 20 msec;
    player1.tempo -> player2.tempo after 20 msec;
}

target C {threads: 1, keepalive: true, flags: "-lncurses"};

/**
 * FIXME: there are still two problems with this implementation:
 * 1. Use of a global variable to let the ncurses thread find the actions
 * that it should schedule. It would be helpful to have some kind of generic
 * framework for setting up interactive tests.
 * 2. When the program runs out of space on the terminal, newlines are ignored.
 * It is not clear to me why this is the case, but I've only just now started
 * using ncurses, which is a pretty rich toolkit. More on ncurses here:
 * http://web.mit.edu/barnowl/src/ncurses/ncurses-5.4/doc/html/ncurses-intro.html
 * 
 * @author Marten Lohstroh
 */
preamble {=
    #include <stdio.h>
	#include <stdlib.h>
	#include <curses.h>

	struct {
        void* brake;
        void* accelerate;
    } pedals;

	int calc_brake_force(int angle) {  // ~0-600 Nm in Tesla Model 3
        return 100 * angle + 50;
    }

	int calc_motor_torque(int angle) {
        return 100 * angle;
    }

	void* read_input(void* arg) {
        initscr();
	    noecho();		   // Don't echo input
	    cbreak();          // Don't interrupt for user input
	    timeout(1);        // Wait for key press in ms
	    printw("***************************************************************\n");
        printw("Press '1-6' to change the angle of the accelerator\n");
        printw("Press 'q-y' to change the angle of the brake pedal\n");
	    char c = 0;         // Command: [1-6|q-y]
	    int v = 0;
	    while (true) {
	    	bool skip = false; // Whether to schedule and event or not  	
	      	c = getch();
	      	switch(c) {
                case 'q':
                	v = 0;
                	break;
                case 'w':
                	v = 1;
                	break;
                case 'e':
                	v = 2;
                	break;
                case 'r':
                	v = 3;
                	break;
                case 't':
                	v = 4;
                	break;
                case 'y':
                	v = 5;
                	break;
                default:
                	skip = true;
                	break;
            }
	      	
	      	if (!skip) {
                schedule_int(pedals.brake, 0, v);
            }
            
           	skip = false;
	      	switch(c) {
                case '1':
                	v = 0;
                	break;
                case '2':
                	v = 1;
                	break;
                case '3':
                	v = 2;
                	break;
                case '4':
                	v = 3;
                	break;
                case '5':
                	v = 4;
                	break;
                case '6':
                	v = 5;
                	break;
                default:
                	skip = true;
                	break;
            }
	      	
	      	if (!skip) {
                schedule_int(pedals.accelerate, 0, v);
            }
	   }
	   endwin();
	   return 0;
	}
	pthread_t curses_thread;
	bool initialized = false;
	void init_sensors() {
        if (!initialized) {
        	pthread_create(&curses_thread, NULL, &read_input, NULL);
        	initialized = true;
        }
    }
=}

reactor MotorControl {
	
	input brkOn:bool;
	input accRate:int;
	output torque:int;
	state braking:bool(true);
	state accelerating:bool(false);
	
	//@label Set torque to zero if car is accelerating
	reaction(brkOn) -> torque {=
		self->braking = brkOn->value;
		if(self->accelerating) {
			SET(torque, 0);
		}
	=}
	
	//@label Adjust torque unless car is braking 
	reaction(accRate) -> torque {= 
		if (!self->braking) {
			SET(torque, calc_motor_torque(accRate->value));
			if (accRate->value > 0) {
            	self->accelerating = true; 
            } else {
                self->accelerating = false;
            }
		} else if (accRate->value > 0){
            printw("Cannot accelerate; release brake pedal first.\n");
        }
	=}
}

reactor BrakePedal { 
	output angle:int;
	output applied:bool;
	
	physical action a(0, 1 msec, "replace"):int;
	state last:int(1);
	
	// @label Setup callback
   	reaction(startup) -> a {=
        pedals.brake = a;
        init_sensors();
	=}
    
    // @label Output reported angle
    reaction(a) -> angle, applied {=
    	if (self->last != a->value) {
        	if (self->last == 0) {
                SET(applied, true); // zero to nonzero
            } else if (a->value == 0) {
                SET(applied, false); // nonzero to zero
            }
            
        	self->last = a->value;
        	
 			SET(angle, a->value);       	
        }
     =}
}

reactor Accelerator {
       
    state pedal:int(-1);
    physical action a(0, 2 msec, "replace"):int;
    output angle:int;
    state last:int(0);
    
    // @label Setup callback
    reaction(startup) -> a {=
        pedals.accelerate = a;
        init_sensors();
	=}
    
    // @label Output reported angle
    reaction(a) -> angle {=
        if (self->last != a->value) {
			SET(angle, a->value);
			self->last = a->value;
        }
    =}    
    
}

// @label Apply the requested force
reactor Brakes {
	input force:int;
	
	// @label Reaction with deadline
	reaction(force) {=
        printw("Adjusting brake power to %dN; on time!\n", force->value);
    =} deadline (2 msec) {=
        printw("Adjusting brake power to %dN; too late!\n", force->value);
    =}
}

// @label Apply the requested torque
reactor Motor {
	input torque:int;
	
	// @label Reaction with deadline
	reaction(torque) {=
        printw("Adjusting engine torque to %dNm; on time!\n", torque->value);
    =} deadline (3 msec) {=
        printw("Adjusting engine torque to %dNm; too late!\n", torque->value);
    =}
}

// @label Adjust the force
reactor BrakeControl {
	input angle:int;
	output force:int;
	
	reaction(angle) -> force {=
        SET(force, calc_brake_force(angle->value));
    =}
}

/**
 * Reactor that implements a simplified power train control module.
 */
main reactor PowerTrain {
    
	bp = new BrakePedal();
	a = new Accelerator();
	bc = new BrakeControl();
	mc = new MotorControl();
	b = new Brakes();
	m = new Motor();
	
	bp.angle -> bc.angle;
	bc.force -> b.force;
	bp.applied -> mc.brkOn;
	mc.torque -> m.torque;
	a.angle -> mc.accRate;
	
}
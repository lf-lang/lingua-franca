/**
 * Example of a basic digital twin setup, with two federates mutating and 
 * maintaining a "lock status" state. 
 *
 * For run instructions, see README.md in the same directory.
 * 
 * @author Hou Seng Wong (housengw@berkeley.edu)
 */

target Python {
    docker: true
};

preamble {=
    import curses
    import threading
=}

/**
 * A key fob that detects "lock" and "unlock" key presses, 
 * and sends and receives lock status to and from other key fobs.
 */
reactor KeyFob {
    state locked({=False=});
    state window({=None=});
    state listener({=None=});
    state log({=list()=});
    state max_log_len(3);
    input get_lock_status;
    output send_lock_status;
    physical action press_lock;
    physical action press_unlock;

    preamble {=
        def print_intro_message(self):
            self.window.addstr(0, 0, "Press 'l' to lock, 'u' to unlock, 'q' to quit")
            self.window.refresh()

        def print_lock_status(self):
            status = "Locked" if self.locked else "Unlocked"
            self.window.addstr(1, 0, f"Lock Status: {status}")
            self.window.clrtoeol()
            self.window.refresh()

        def print_log(self):
            text = "Log is empty"
            if len(self.log) > 0:
                for i, line in enumerate(self.log):
                    log_message = self.format_log_message(line)
                    self.window.addstr(2 + i, 0, log_message)
                    self.window.clrtoeol()
                self.window.refresh()
        
        def format_log_message(self, line):
            elapsed_ptime, tag, remote, locked = line
            return (f"At (tag: ({'{:,}'.format(tag.time)} ns, {tag.microstep}), "
                    f"lag: {'{:,}'.format(elapsed_ptime - tag.time)} ns), "
                    f"{'Received' if remote else 'Set'} lock state as: {'Locked' if locked else 'Unlocked'}")

        # log structure: (elapsed_physical_time:int, tag:int, remote:bool, locked:bool)
        def append_log(self, remote, locked):
            elapsed_tag = Tag(get_elapsed_logical_time(), get_microstep())
            log_entry = (get_elapsed_physical_time(), elapsed_tag, remote, locked)
            self.log.append(log_entry)
            if len(self.log) > self.max_log_len:
                self.log.pop(0)

        def listen_for_keypress(self, press_lock, press_unlock):
            key = ""
            while key != ord("q"):
                key = self.window.getch()
                if key == ord("l"): 
                    press_lock.schedule(0)
                elif key == ord("u"):
                    press_unlock.schedule(0)
            request_stop()
    =}

    reaction(startup) -> press_lock, press_unlock {=
        self.window = curses.initscr()
        curses.cbreak()
        curses.noecho()
        self.window.keypad(True)
        self.print_intro_message()
        self.print_lock_status()
        self.print_log()
        t = threading.Thread(target=self.listen_for_keypress, args=(press_lock, press_unlock))
        self.listener = t
        t.start()
    =}

    reaction(press_lock) -> send_lock_status {=
        self.append_log(remote=False, locked=True)
        self.locked = True
        self.print_lock_status()
        self.print_log()
        send_lock_status.set(True)
    =}

    reaction(press_unlock) -> send_lock_status {=
        self.append_log(remote=False, locked=False)
        self.locked = False
        self.print_lock_status()
        self.print_log()
        send_lock_status.set(False)
    =}

    reaction(get_lock_status) {=
        self.append_log(remote=True, locked=get_lock_status.value)
        self.locked = get_lock_status.value
        self.print_lock_status()
        self.print_log()
    =}

    reaction(shutdown) {=
        self.listener.join()
        curses.endwin()
    =}
}

federated reactor {
    fob = new KeyFob();
    twin = new KeyFob();
    fob.send_lock_status -> twin.get_lock_status;
    twin.send_lock_status -> fob.get_lock_status;
}
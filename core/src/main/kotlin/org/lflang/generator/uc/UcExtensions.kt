package org.lflang.generator.uc

import org.eclipse.emf.ecore.resource.Resource
import org.lflang.*
import org.lflang.generator.cpp.CppInstanceGenerator.Companion.isEnclave
import org.lflang.lf.BuiltinTriggerRef
import org.lflang.lf.Expression
import org.lflang.lf.Port
import org.lflang.lf.Preamble
import org.lflang.lf.Reaction
import org.lflang.lf.Reactor
import org.lflang.lf.TriggerRef
import org.lflang.lf.VarRef
import org.lflang.lf.Visibility
import org.lflang.lf.WidthSpec
import org.lflang.target.property.type.LoggingType.LogLevel

/* *******************************************************************************************
 *
 * The following definition provide extension that are likely useful across targets
 *
 * TODO Move these definitions to a common place and check if they are already implemented elsewhere
 */

/** Get the "name" a reaction is represented with in target code.*/
val Reaction.codeName
    get(): String = name ?: "reaction_$priority"

/* **********************************************************************************************
 * C++ specific extensions shared across classes
 */
// TODO: Most of the extensions defined here should be moved to companion objects of their
//  corresponding generator classes. See for instance the CppParameterGenerator

///** Convert a LF time value to a representation in C++ code */
fun TimeValue.toCCode() = UcTypes.getTargetTimeExpr(this)
//
///**
// * Convert a LF time value to a representation in C++ code.
// * @param inferredType Type that the expr has (or null), may guide code generation if ambiguous
// */
fun Expression.toCCode(inferredType: InferredType? = null): String =
    UcTypes.getTargetExpr(this, inferredType)
//
//
///**
// * Convert a value to a time representation in C++ code
// *
// * If the value evaluates to 0, it is interpreted as a time.
// *
// */
fun Expression?.toCTime(): String =
    this?.toCCode(inferredType = InferredType.time()) ?: "reactor::Duration::zero()"
//

//
///** True if the preamble is public */
//val Preamble.isPublic: Boolean get() = this.visibility == Visibility.PUBLIC
//
///** True if the preamble is private */
//val Preamble.isPrivate: Boolean get() = this.visibility == Visibility.PRIVATE
//
///** The template line preceding the class declaration and any member definitions for a `reactor */
//val Reactor.templateLine
//    get() =
//        if (isGeneric) """template<${typeParms.joinToString(", ") { "class ${it.toText()}" }}>"""
//        else ""
//
///** Get templated name of a reactor class */
//val Reactor.templateName: String get() = if (isGeneric) "$name<${typeParms.joinToString(", ") { it.toText() }}>" else name
//
///** Get a C++ code representation of the given variable */
//val VarRef.name: String
//    get() = when {
//        container == null -> variable.name
//        container.isEnclave -> "${container.name}->__lf_instance->${variable.name}"
//        else -> "${container.name}->${variable.name}"
//    }
//
///** Get a C++ code representation of the given trigger */
//val TriggerRef.name: String
//    get() = when (this) {
//        is VarRef            -> this.name
//        is BuiltinTriggerRef -> type.literal
//        else                 -> unreachable()
//    }
//
///** Return a comment to be inserted at the top of generated files. */
//fun fileComment(r: Resource) = """
//    /*
//     * This file was autogenerated by the Lingua Franca Compiler.
//     *
//     * Source: ${r.uri}
//     */
//    """.trimIndent()
//
//val InferredType.cppType: String
//    get() = CppTypes.getTargetType(this)
//
//
///** Convert a log level to a severity number understood by the reactor-cpp runtime. */
//val LogLevel.severity
//    get() = when (this) {
//        LogLevel.ERROR -> 1
//        LogLevel.WARN -> 2
//        LogLevel.INFO -> 3
//        LogLevel.LOG   -> 4
//        LogLevel.DEBUG -> 4
//    }
//
//fun Reactor.hasBankIndexParameter() = parameters.firstOrNull { it.name == "bank_index" } != null

package org.lflang.analyses.dag;

import java.util.List;
import org.lflang.TimeValue;
import org.lflang.analyses.pretvm.instructions.Instruction;
import org.lflang.generator.ReactionInstance;

/**
 * Class defining a Dag node.
 *
 * <p>FIXME: Create subclasses for ReactionNode and SyncNode
 *
 * @author Chadlia Jerad
 * @author Shaokai Lin
 */
public class DagNode implements Comparable<DagNode> {
  /** Different node types of the DAG */
  public enum dagNodeType {
    DUMMY,
    SYNC,
    REACTION
  }

  /**
   * An integer that counts the number of times the same node has occured in the graph. The value 0
   * means unassigned.
   */
  public int count = 0;

  /** Node type */
  public dagNodeType nodeType;

  /** If the node type is REACTION, then point the reaction */
  public ReactionInstance nodeReaction;

  /** If the node type is Dummy or SYNC, then store the time step, respectiveley time */
  public TimeValue timeStep;

  /**
   * Worker ID that owns this node, if this node is a reaction node. The value -1 means unassigned.
   */
  private int worker = -1;

  /** Color of the node for DOT graph */
  private String hexColor = "#FFFFFF";

  /**
   * A DAG node can be associated with a SYNC node, indicating the "release time" of the current
   * node. The SYNC node is one with the maximum tag among all of the upstream SYNC nodes wrt the
   * current node.
   */
  private DagNode associatedSyncNode;

  /** A debug message in the generated DOT */
  private String dotDebugMsg = "";

  /**
   * If the dag node is a REACTION node and there is another node owned by another worker waiting
   * for the current reaction node to finish, the release value is the number assigned an WU
   * instruction executed by the other worker. The other worker needs to wait until the counter of
   * this worker, who owns this reaction node, reaches releaseValue. We store this information
   * inside a dag node. This value is assigned only after partitions have been determined.
   */
  private Long releaseValue;

  /** A list of PretVM instructions generated for this DAG node. */
  // private List<Instruction> instructions = new ArrayList<>();

  /**
   * Constructor. Useful when it is a SYNC or DUMMY node.
   *
   * @param type node type
   * @param timeStep if the type is DYMMY or SYNC, then record the value
   */
  public DagNode(dagNodeType type, TimeValue timeStep) {
    this.nodeType = type;
    this.timeStep = timeStep;
  }

  /**
   * Constructor. Useful when it is a REACTION node.
   *
   * @param type node type
   * @param reactionInstance reference to the reaction
   */
  public DagNode(dagNodeType type, ReactionInstance reactionInstance) {
    this.nodeType = type;
    this.nodeReaction = reactionInstance;
  }

  public ReactionInstance getReaction() {
    return this.nodeReaction;
  }

  public String getColor() {
    return this.hexColor;
  }

  public void setColor(String hexColor) {
    this.hexColor = hexColor;
  }

  public int getWorker() {
    return this.worker;
  }

  public void setWorker(int worker) {
    this.worker = worker;
  }

  public String getDotDebugMsg() {
    return this.dotDebugMsg;
  }

  public void setDotDebugMsg(String msg) {
    this.dotDebugMsg = msg;
  }

  public boolean isAuxiliary() {
    return (nodeType == dagNodeType.SYNC || nodeType == dagNodeType.DUMMY);
  }

  public int getCount() {
    return count;
  }

  public void setCount(int count) {
    this.count = count;
  }

  public DagNode getAssociatedSyncNode() {
    return associatedSyncNode;
  }

  public void setAssociatedSyncNode(DagNode syncNode) {
    this.associatedSyncNode = syncNode;
  }

  public Long getReleaseValue() {
    return releaseValue;
  }

  public void setReleaseValue(Long value) {
    releaseValue = value;
  }

  /**
   * Get instructions generated by this node for a specific worker's instructions. It is important
   * to note that nodes do NOT memorize instructions internally, because the instructions and their
   * order change in the schedule during optimization passes. So source of truth should come from
   * the workerInstructions list. Each instruction memorizes the node it belongs to. When we want to
   * query a list of instructions owned by a node, a _view_ of workerInstructions is generated to
   * collect instructions which belong to that node.
   */
  public List<Instruction> filterInstructions(List<Instruction> workerInstructions) {
    return workerInstructions.stream().filter(it -> it.getDagNodes().contains(this)).toList();
  }

  /**
   * A node is synonymous with another if they have the same nodeType, timeStep, and nodeReaction.
   */
  public boolean isSynonyous(DagNode that) {
    if (this.nodeType == that.nodeType
        && (this.timeStep == that.timeStep
            || (this.timeStep != null
                && that.timeStep != null
                && this.timeStep.compareTo(that.timeStep) == 0))
        && this.nodeReaction == that.nodeReaction) return true;
    return false;
  }

  /**
   * Compare two dag nodes based on their timestamps.
   *
   * @param other The other dag node to compare against.
   * @return -1 if this node has an earlier timestamp than that node, 1 if that node has an earlier
   *     timestamp than this node, 0 if they have the same timestamp.
   */
  @Override
  public int compareTo(DagNode that) {
    return TimeValue.compare(this.timeStep, that.timeStep);
  }

  @Override
  public String toString() {
    return nodeType
        + " node"
        + (this.timeStep == null ? "" : " @ " + this.timeStep)
        + (this.getReaction() == null ? "" : " for " + this.getReaction())
        + (this.count == -1 ? "" : " (count: " + this.count + ")");
  }
}

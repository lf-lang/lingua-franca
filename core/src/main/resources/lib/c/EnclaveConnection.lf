/**
 * Library reactor implementing an Enclaved connection. It is used by
 * the code-generator when it finds a connection between two enclaves. Any event
 * written to the input port of this reactor is first scheduled on to an action
 * and then later written to the output port. This reactor is situated between
 * two environments and expects to have pointers to both of them as parameters.
 *
 * It supports sending events carrying primitive types and token types. It does
 * not support array types.
 *
 * The reactions of this reactor are unordered. The reaction to the input port
 * is executed in the source environment, and the reactions that write to the
 * output ports are executed in the destination environment. Only one of the
 * output reactions will ever be executed, depending on whether the connection
 * is physical or logical.
 */
target C;

@_enclave_connection
reactor _EnclaveConnection<T>(
  source_env: environment_t* = 0,
  dest_env: environment_t* = 0,
  has_after_delay: bool = false, 
  delay: time = 0 msec, 
  is_physical: bool = false) {

  logical action logAction: T
  physical action phyAction: T

  input in: T
  output out: T

  preamble {=
    #ifdef __cplusplus
    extern "C" {
    #endif
      #include "reactor_common.h"
      #include "rti_local.h"
      #include <string.h>
    #ifdef __cplusplus
    }
    #endif
  =}

  /**
   * @brief The forward reaction for logical actions.
   * 
   * This reaction takes the event which was scheduled to the action and writes it to the output port.
   * It executes in the destination environment.
   */
  reaction(logAction) -> out {=
    #if defined T_IS_TOKEN_TYPE
      out->value = (T) logAction->token->value;
      _lf_replace_template_token((token_template_t*)out, logAction->token);
      out->is_present=true;
    #else
      lf_set(out, *(T*)(logAction->token->value));
    #endif
  =}

  /**
   * @brief The forward reaction for physical actions.
   * 
   * This reaction takes the event which was scheduled to the action and writes it to the output port.
   * It executes in the destination environment.
   */
  reaction(phyAction) -> out {=
    #if defined T_IS_TOKEN_TYPE
      out->value = (T) phyAction->token->value;
      _lf_replace_template_token((token_template_t*)out, phyAction->token);
      out->is_present=true;
    #else
      lf_set(out, *(T*)(phyAction->token->value));
    #endif
  =}

  /**
   * @brief The input reaction.
   * 
   * This takes an event from the input port and schedules
   * an event on the correct action within the destinaton environment.
   * This reaction executes in the source environment.
   */
  reaction(in) -> logAction, phyAction {=
    lf_critical_section_enter(self->dest_env);
    if (self->is_physical) {
      // Schedule event onto the physical action.
      #if defined T_IS_TOKEN_TYPE
        // If we have a token-type, simply schedule the token at the desired tag"
        if(_lf_schedule_token(self->dest_env, phyAction, self->delay, in->token) < 0) {
          lf_print_warning("Could not schedule event onto downstream enclave.");
        }
      #else
        // If we have a native type:
        if (_lf_schedule_copy(self->dest_env, phyAction, self->delay, &in->value, 1) < 0) {
          lf_print_warning("Could not schedule event onto downstream enclave.");
        }
      #endif
      // Notify the main thread in case it is waiting for physical time to elapse
      lf_notify_of_event(self->dest_env);
    } else {
      // Schedule event onto the logical action.
      // Calculate the logical tag the event should get in the target environment.
      tag_t target_tag = self->source_env->current_tag;
      if (self->has_after_delay) {
        target_tag = lf_delay_tag(self->source_env->current_tag, self->delay);
      }
      if(!lf_is_tag_after_stop_tag(self->dest_env, target_tag)) {
        #if defined T_IS_TOKEN_TYPE
          // If we have a token-type, simply schedule the token at the desired tag"
          if (_lf_schedule_at_tag(self->dest_env, logAction->_base.trigger, target_tag, in->token) < 0) {
            lf_print_warning("Could not schedule event onto downstream enclave.");
          }
        #else
          // If we have a native type:
          int length = 1;
          if (in->token) length = in->length;
          // The following is copied from `lf_schedule_copy` except for using"
          //  `_lf_schedule_at_tag`:
          token_template_t* tmplate = (token_template_t*)logAction;
          lf_token_t* token = _lf_initialize_token(tmplate, length);
          memcpy(token->value, &(in->value), tmplate->type.element_size * length);
          // Schedule event to the destination environment.
          if(_lf_schedule_at_tag(self->dest_env, logAction->_base.trigger, target_tag, token) < 0) {
            lf_print_warning("Could not schedule event onto downstream enclave.");
          }
        #endif
        // Notify the main thread in case it is waiting for physical time to elapse
        lf_notify_of_event(self->dest_env);
        // Notify the local RTI that we have scheduled something onto the event queue of another enclave
        rti_update_other_net_locked(self->source_env->enclave_info, self->dest_env->enclave_info, target_tag);
      }
    }
    lf_critical_section_exit(self->dest_env);
  =}
}



// The Multiport tests the present_indices_unsorted() function in the reactor::Multiport class. This
// method returnes all present ports this test checks if the returned list of indices is correctly
// generated by the runtime. For that we manually recreate this list and check if they are
// identical. If they are not identical the Multiport and Port Class do not correctly exchange
// information.
//
// Author: Tassilo Tanneberger <tassilo.tanneberger@tu-dresden.de>
target Cpp

reactor Test {
  input[3000] sink: void
  output[3000] source: void

  reaction(sink) -> source {=
    for (auto i: sink.present_indices_unsorted()) {
      source[i].set();
    }
  =}
}

main reactor Multiport {
  test = new Test()
  state received: bool = false

  reaction(startup) -> test.sink {=
    for (auto i = 0; i < 30; i++) {
      auto semi_random_index = (i * 100) % 3000;
      test.sink[semi_random_index].set();
    }
  =}

  reaction(test.source) {=
    received = true;
    std::vector<std::size_t> positions;

    for (auto i = 0; i < 30; i++) {
      auto semi_random_index = (i * 100) % 3000;
      positions.push_back(semi_random_index);
    }

    auto received_indices = test.source.present_indices_unsorted();

    if (positions.size() != received_indices.size()) {
      std::cerr << "positions size:" << positions.size()
            << " indices size:" << received_indices.size() << std::endl;
      throw std::runtime_error("not matching sizes");
    }

    for (auto i = 0; i < positions.size(); i++) {
      if (positions[i] != received_indices[i]) {
        std::cerr << "mismatch detected:" << positions[i] << " and " << received_indices[i] << std::endl;
        throw std::runtime_error("indices do not match");
      }
    }

    std::cout << "[SUCCESS] all indices match" << std::endl;
  =}

  reaction(shutdown) {=
    if (!received) {
      std::cerr << "Error: received no input!\n";
      exit(2);
    }
  =}
}

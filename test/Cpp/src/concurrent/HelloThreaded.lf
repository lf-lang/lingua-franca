// This test checks that logical time is incremented an appropriate amount as a result of an
// invocation of the schedule() function at runtime. It also performs various smoke tests of timing
// aligned reactions. The first instance has a period of 4 seconds, the second of 2 seconds, and the
// third (composite) or 1 second.
target Cpp {
  timeout: 10 sec,
  fast: true
}

reactor HelloCpp(period: time = 2 sec, message: {= std::string =} = "Hello C++") {
  state count: int = 0
  state previous_time: {= reactor::TimePoint =}
  timer t(1 sec, period)
  logical action a: void

  reaction(t) -> a {=
    std::cout << message << std::endl;
    a.schedule(200ms); // No payload.
    // Print the current time.
    previous_time = get_logical_time();
    std::cout << "Current time is " << previous_time << std::endl;
  =}

  reaction(a) {=
    count++;
    auto time = get_logical_time();
    std::cout << "***** action " << count << " at time "
           << time << std::endl;
    auto diff = time - previous_time;
    if (diff != 200ms) {
      std::cerr << "FAILURE: Expected 200 msecs of logical time to elapse "
            << "but got " << diff << std::endl;
      exit(1);
    }
  =}
}

reactor Inside(period: time = 1 sec, message: {= std::string =} = "Composite default message.") {
  third_instance = new HelloCpp(period=period, message=message)
}

main reactor {
  first_instance = new HelloCpp(period = 4 sec, message = "Hello from first_instance.")
  second_instance = new HelloCpp(message = "Hello from second_instance.")
  composite_instance = new Inside(message = "Hello from composite_instance.")
}

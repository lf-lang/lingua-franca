# Status

This is not exhaustive. Ideally each of those bullet points would have a test case.

## Language

- [x] reactor composition
  - [x] `CompositionInitializationOrder.lf`: startup reactions are called bottom-up
  - [x] `CompositionWithPorts.lf`: port bindings work
- [ ] ports
    - [x] `PortValueCleanup.lf`: port value is cleaned up at the end of a tag
    - [x] `PortRefCleanup.lf`: port value is cleaned up at the end of a tag, when the upstream is a port reference
    - [x] connections...
      - [x] `PortConnectionInSelfInChild.lf`: input of self to input of child
      - [x] `PortConnectionInSelfOutSelf.lf`: input of self to output of self
      - [x] `PortConnectionOutChildOutSelf.lf`: output of child to output of self
      - [x] `CompositionWithPorts.lf`: output of child to input of child
    - [ ] connections with non-zero delay (`a.o -> b.i after 1 ms`)
    - [ ] mutable inputs
- [x] reaction dependency handling
    - dependencies can be declared...
      - [x] all test files: on ports of this reactor
      - [x] `DependencyOnChildPort.lf`: on ports of a child reactor
      - [x] `DependencyThroughChildPort.lf`: on ports of a child, triggers child reactions
      - [x] all test files: on an action
    - [x] trigger dependencies
      - [x] all test files: trigger dependencies trigger reactions
      - [x] `ActionIsPresentDouble.lf`: multiple trigger dependencies may be triggered independently
    - [x] uses-dependencies
      - [x] `DependencyUseNonTrigger`: use dependencies do not trigger reactions
      - [x] `DependencyUseAccessible`: use dependencies make the port accessible within the reaction, values are observable
      - [x] `DependencyUseOnLogicalAction.lf`: use dependencies may be declared on actions and timers
    - [x] effects-dependency
      - [x] all test files: effects dependencies allow mutation
    - [x] reaction priority is respected
      - [x] locally
      - [x] between different child reactors
- [ ] imports:
  - [x] `Import.lf`: imports, including recursive import
  - [ ] visibility of imported preambles
- [x] preambles
  - [x] `Preamble.lf`: preamble within reactor
  - [ ] top-level preamble
- [x] logical actions
    - [x] `ActionImplicitDelay.lf`: scheduling an action with no additional delay uses its implicit delay
    - [x] `ActionDelay.lf`:
    - [x] `ActionScheduleMicrostep.lf`: an action scheduled with a zero delay is only triggered on the next microstep
    - [x] `ActionValues.lf`: scheduling an action with a value at multiple different tags preserves each value
    - [x] `ActionValuesCleanup.lf`: action value is cleaned up at the end of a tag
    - [x] `ActionIsPresent.lf`: function `is_present` checks whether an action is present at the current tag
    - [x] `ActionIsPresentDouble.lf`: several actions may be present at the same tag
    - [ ] minimum spacing and spacing violation policy
    - [ ] todo does scheduling an action twice produce two separate triggers at the same instant? -> no
- [ ] physical actions
  - [x] `PhysicalActionWithKeepalive.lf`: keepalive option should keep the scheduler alive when there are async threads which can send notifications
  - [x] `PhysicalActionWakesSleepingScheduler.lf`: a physical action triggered during a period of idleness of the scheduler should wake it timely
  - [x] `PhysicalActionKeepaliveIsSmart.lf`: keepalive option doesn't keep the program alive if live threads do not have a reference to the scheduler
  - [x] `PhysicalActionCanBeScheduledSynchronously.lf`: physical actions do not need to be carried by an asynchronous thread to be scheduled. When they are scheduled within a reaction, they still use physical time and not logical time.
  - [ ] todo does shutdown abort async threads or not?
- [x] timers
  - [x] `TimerDefaults.lf`: timer with all params defaulted (`timer t;`) is non-periodic and has offset zero
  - [x] `TimerPeriodic.lf`: timer can be periodic
  - [x] `TimerIsPresent.lf`: timer should be queryable with `is_present`
  - [x] timer cannot be scheduled manually
- [x] `shutdown` trigger & `request_stop`
  - [x] `Stop.lf`: `request_stop` schedules a shutdown at T+(1 microstep)
  - [x] `StopCleanup.lf`: ports are cleaned up before the shutdown wave executes
  - [x] `StopTopology.lf`: shutdown wave occurs in topological order like a normal wave
  - [x] `StopTimeout.lf`: `shutdown` is triggered even if the program exits because of timeout target property
  - [x] `StopTimeoutExact.lf`: tests that if a timeout coincides with another event, both events are handled during shutdown.
  - [x] `StopNoEvent.lf`: `shutdown` is triggered even if the program exits because of an empty event queue
  - [x] `StopIdempotence.lf`: `request_stop` may be called within the shutdown wave, but it should have no effect.
  - [x] `StopDuringStartup.lf`: `request_stop` may be called within startup.
  - [x] `StopAsync.lf`: it should be possible to request shutdown asynchronously
- [x] state variables
  - [x] `TimeState.lf`: support time type
  - [x] `StateDefaultValue.lf`: if initializer is missing, `Default::default()` is used
  - [x] are accessible within reactions
  - [x] `StateInitializerVisibility.lf`: are accessible within initializers of other state vars (no forward reference allowed though)
  - [x] are initialized to their proper value
- [x] reactor parameters
  - [x] `CtorParamSimple.lf`: ctor parameters are accessible in initializers and reactions
  - [x] `CtorParamDefault.lf`: ctor arguments may be defaulted
  - [x] `CtorParamMixed.lf`: ctor arguments may be mentioned in any order, even with defaulted parameters
  - note: must be `Clone`
- [ ] array types
  - [x] support fixed-sized arrays
  - [x] `TypeVarLengthList.lf`: support variable length lists (`Vec`)
  - [x] support array initializer syntax
  - [ ] support array assignment syntax (needs #544)
- [ ] deadlines
  -  shouldn't be so hard to implement
- [ ] reactor inheritance
  - ...
- [ ] multiports and banks of reactors
  - [x] `MultiportIn.lf`: support banks of input ports and connections to individual channels
  - [x] `MultiportOut.lf`: support banks of output ports and connections to individual channels
  - [x] `MultiportFromHierarchy.lf`: support binding an output bank to an input bank within a composition
  - [x] `MultiportToBank.lf`: support binding an output multiport to the input of a bank
  - [x] `MultiportToBank.lf`: support the special `bank_index` parameter
  - [x] `MultiportToMultiport.lf`: test a connection multiport to multiport (same width)
  - [x] `MultiportToMultiport2.lf`: test a sparse connection between multiports (some channels are left disconnected)
  - [x] `FullyConnected.lf`: iterated connection from a bank to a multiport
  - self connections. These used to cause problems with borrows, and we have to use unsafe code to make this work.
    - [x] `ConnectionToSelfBank.lf`: connection from a bank to a port of the same reactor
    - [x] `ConnectionToSelfMultiport.lf`: connection from a multiport to another multiport of the same reactor
- [x] generics
  - [x] `GenericReactor.lf`: generic reactors may compose, types are properly instantiated
  - [x] `CtorParamGeneric.lf`: ctor parameters may refer to type parameters
  - [x] `CtorParamGenericInst.lf`: generic ctor parameters work properly when creating child instance

### Runtime

- [x] parallelize independent computation
  - [x] feature-gated by Cargo (`--features parallel-runtime`)
  - [ ] make usable as target property
  - [ ] maybe stop using rayon and use your own thread pool and concurrency primitives (far away)
- [ ] runtime parameters
  - [x] `PhysicalActionWithKeepalive.lf`: ~keepalive option~ keepalive isn't needed in Rust
  - [x] timeout option
- [ ] error recovery
  - [ ] unwind safety around reaction invocation, possibly a panic handler
- [ ] tracing
  - [ ] binary trace format -> you need benchmarks to measure overhead first
  - [ ] dumping dependency graph

### Rust-specific code generator features

- [ ] benchmark generation
- interfacing with Rust ecosystem
  - [x] `target/CargoDependency.lf`: generated project can depend on external crates, including local ones
  - [x] `target/CargoDependencyOnRuntime.lf`: Specify runtime crate as a cargo dependency
  - [x] `target/ModuleDependency.lf`: one can add pure rust modules to the generated project without fuss
  - [x] `target/ModuleDependencyWithDirModule.lf`: one can also add a tree of modules
  - [x] `target/BuildProfileRelease.lf`: one can select the *release* build profile with the `build-type` property
  - [x] `target/BuildProfileDefaultIsDev.lf`: default Cargo build profile is *dev*
- `target/CliFeature.lf`: CLI parameter parsing
  - [x] for runtime options
  - [x] for parameters of the main reactor
    - [ ] not sure how to write a test for this

/**
 * Check whether the internally generated network and control reactions
 * introduce a cycle or not. The failure for this test is not being compiled.
 * @author Edward A. Lee
 */
target Python

reactor CAReplica {
    input local_update
    input remote_update
    input query

    state balance(0)

    output response

    reaction(local_update, remote_update) {=
        if local_update.is_present:
            self.balance += local_update.value
        if remote_update.is_present:
            self.balance += remote_update.value
    =}

    reaction(query) -> response {= response.set(self.balance) =}
}

reactor UserInput {
    preamble {= import sys =}
    input balance
    output deposit

    reaction(startup) -> deposit {= deposit.set(100) =}

    reaction(balance) {=
        if balance.value != 200:
            self.sys.stderr.write("Did not receive the expected balance. Expected: 200. Got: {}.\n".format(balance.value))
            self.sys.exit(1)
        print("Balance: {}".format(balance.value))
        lf_request_stop()
    =}

    reaction(shutdown) {= print("Test passed!") =}
}

federated reactor {
    u1 = new UserInput()
    r1 = new CAReplica()
    u2 = new UserInput()
    r2 = new CAReplica()
    (u1.deposit)+ -> r1.query, r1.local_update
    r1.response -> u1.balance
    u1.deposit -> r2.remote_update

    (u2.deposit)+ -> r2.query, r2.local_update
    r2.response -> u2.balance
    u2.deposit -> r1.remote_update
}

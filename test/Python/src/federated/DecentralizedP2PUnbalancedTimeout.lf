/**
 * Test a source-destination scenario where the source falls behind real-time, and reaches the
 * timeout much later than the destination. In this test, the destination closes the connection
 * early, causing the transmission to fail. Warnings will be printed about lost messages.
 *
 * The test fails if the federation does not exit.
 */
target Python {
  timeout: 1 msec,
  coordination: decentralized
}

# reason for failing: lf_tag() not supported by the python target
reactor Clock(offset=0, period = 1 sec) {
  output y
  timer t(offset, period)
  state count = 0

  reaction(t) -> y {=
    self.count += 1
    print("Sending {}.".format(self.count))
    y.set(self.count)
  =}

  reaction(shutdown) {= print("SUCCESS: the source exited successfully.") =}
}

reactor Destination {
  preamble {= import sys =}
  input x
  state s = 1
  state startup_logical_time

  reaction(startup) {= self.startup_logical_time = lf.time.logical() =}

  reaction(x) {=
    print("Received {}".format(x.value))
    current_tag = lf.tag()
    if x.value != self.s:
      error_msg = "At tag ({}, {}) expected {} and got {}.".format(current_tag.time - self.startup_logical_time, current_tag.microstep, self.s, x.value)
      self.sys.stderr.write(error_msg)
      self.sys.exit(1)
    self.s += 1
  =}

  reaction(shutdown) {=
    print("**** shutdown reaction invoked.")
    print("Approx. time per reaction: {}ns".format(lf.time.physical_elapsed()//(self.s+1)))
  =}
}

federated reactor(period = 10 usec) {
  c = new Clock(period=period)
  d = new Destination()
  c.y -> d.x
}

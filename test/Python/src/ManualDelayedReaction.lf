target Python {
  # Set keepalive to false since this is a test and schedule is called on a physical action from
  # within a reaction. This is one of the special rare cases where the user might want to manually
  # override keepalive.
  keepalive: false
}

# That's the stuff that shall be generated for the after
reactor GeneratedDelay {
  input y_in
  output y_out
  state y_state = 0

  physical action act(0 msec)  # TODO: delay in act or the schedule call?

  reaction(y_in) -> act {=
    self.y_state = y_in.value
    act.schedule(MSEC(100))
  =}

  reaction(act) -> y_out {= y_out.set(self.y_state) =}
}

reactor Source {
  output out
  timer t

  reaction(t) -> out {= out.set(1) =}  # reaction(t) -> out after 100 msec
}

reactor Sink {
  input s_in

  reaction(s_in) {=
    elapsed_logical = lf.time.logical_elapsed()
    logical = lf.time.logical()
    physical = lf.time.physical()
    print("Nanoseconds since start: {:d} {:d} {:d}.\n".format(logical, physical, elapsed_logical))
    if elapsed_logical < MSEC(100):
      sys.stderr.write("Expected {:d} but got {:d}.\n".format(MSEC(100), elapsed_logical))
      exit(1)
  =} deadline(200 msec) {=  =}
}

main reactor ManualDelayedReaction {
  source = new Source()
  sink = new Sink()
  g = new GeneratedDelay()

  source.out -> g.y_in  # source.out -> sink.s_in; rewritten above
  g.y_out -> sink.s_in
}

/**
 * This example creates a Protocol Buffer message and passes it to another reactor without packing
 * and unpacking. This demonstrates that local communication, within one shared-memory machine, need
 * not incur the overhead of packing and unpacking.
 *
 * To run this example first install the protocol buffers compiler from
 * https://github.com/protocolbuffers/protobuf. It is also available from homebrew on a Mac via
 *
 * $ brew install protobuf
 *
 * Building protobuf from source is slow, so avoid doing that if possible. Next install the C plugin
 * for protocol buffers from
 *
 * https://github.com/protobuf-c/protobuf-c
 *
 * The code generator assumes that executables are installed within the PATH. On a Mac, this is
 * typically at /usr/local/bin.
 */
target C {
  protobufs: [Hello.proto],
  timeout: 1 s
}

reactor SourceProto {
  output out: Hello*

  reaction(startup) -> out {=
    Hello* value = (Hello*)malloc(sizeof(Hello));
    hello__init(value);
    value->name = "Hello World";
    value->number = 42;
    lf_set(out, value);
  =}
}

reactor SinkProto {
  preamble {=
    // FIXME: Ideally, this function would be generated by the tool
    // processing the .proto file.
    // Destructor to use at the receiving end, which frees the memory used to unpack the message.
    void hello_unpacked_destructor(void* hello) {
      Hello* cast = (Hello*)hello;
      hello__free_unpacked(cast, NULL);
    }
    // FIXME: Should also provide a copy constructor.
  =}

  input in: Hello*

  reaction(startup) in {=
    // FIXME: Ideally, this would be automatically generated.
    lf_set_destructor(in, hello_unpacked_destructor);
  =}
  reaction(in) {=
    printf("Received: name=\"%s\", number=%d.\n", in->value->name, in->value->number);
  =}
}

federated reactor {
  s = new SourceProto()
  d = new SinkProto()
  s.out -> d.in serializer "proto"
}

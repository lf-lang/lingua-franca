target C {
  scheduler: {
    type: STATIC,
    mapper: LB,
  },
  workers: 2,
  timeout: 100 sec,
  fast: true,
  // logging: Debug,
}

preamble {=
#define EXPECTED 100030000
=}

reactor Source(id : int = 0) {
  output out: int
  output out2: int
  timer t(1 msec, 10 msec)
  state s: int = 0

  @wcet("1 ms, 500 us")
  reaction(startup) {= 
    // lf_print("[Source %d reaction_1] Starting Source", self->id); 
  =}

  @wcet("3 ms, 500 us")
  reaction(t) -> out, out2 {=
    self->s++;
    lf_set(out, self->s);
    lf_set(out2, self->s);
    // lf_print("[Source %d reaction_2] Inside source reaction_1", self->id);
  =}
}

reactor Sink {
  input in: int
  input in2: int
  timer t(1 msec, 5 msec)
  state sum: int = 0

  @wcet("1 ms, 500 us")
  reaction(startup) {= 
    // lf_print("[Sink reaction_1] Starting Sink"); 
  =}

  @wcet("1 ms, 500 us")
  reaction(t) {=
    self->sum++;
    // lf_print("[Sink reaction_2] Sum: %d", self->sum);
  =}

  @wcet("1 ms, 500 us")
  reaction(in) {=
    self->sum += in->value;
    // lf_print("[Sink reaction_3] Sum: %d", self->sum);
  =}

  @wcet("1 ms, 500 us")
  reaction(in2) {=
    self->sum += in2->value;
    // lf_print("[Sink reaction_4] Sum: %d", self->sum);
  =}

  @wcet("1 ms, 500 us")
  reaction(shutdown) {=
    if (self->sum != EXPECTED) {
      fprintf(stderr, "[Sink reaction_5] FAILURE: Expected %d, Received %d\n", EXPECTED, self->sum);
      exit(1);
    } else {
      lf_print("Successfully received %d", self->sum);
    }
  =}
}

main reactor {
  source = new Source(id=0)
  source2 = new Source(id=1)
  sink = new Sink()
  sink2 = new Sink()
  source.out -> sink.in
  source2.out -> sink.in2
  source.out2 -> sink2.in
  source2.out2 -> sink2.in2
}

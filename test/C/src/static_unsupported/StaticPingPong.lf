/**
 * Basic benchmark from the Savina benchmark suite that is intended to measure message-passing
 * overhead. See [Benchmarks wiki page](https://github.com/icyphy/lingua-franca/wiki/Benchmarks).
 * This is based on https://www.scala-lang.org/old/node/54 See
 * https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 *
 * Ping introduces a microstep delay using a logical action to break the causality loop.
 *
 * To get a sense, some (informal) results for 1,000,000 ping-pongs on my Mac:
 *
 * Unthreaded: 97 msec Threaded: 265 msec
 *
 * There is no parallelism in this application, so it does not benefit from being being threaded,
 * just some additional overhead.
 *
 * These measurements are total execution time, including startup and shutdown. These are about an
 * order of magnitude faster than anything reported in the paper.
 *
 * @author Edward A. Lee
 */
target C {
  fast: true  // single-threaded: true,
}

reactor WrapperPing(count: size_t = 10000000) {
  ping = new Ping(count=count)

  input receive: size_t
  input start: bool
  output send: size_t
  output finished: bool

  receive -> ping.receive
  start -> ping.start

  ping.send -> send
  ping.finished -> finished

  ping.serve_out -> ping.serve_in after 1 msec
}

reactor Redirect {
  input in: int
  output out: int

  reaction(in) -> out {=  =}
}

reactor Ping(count: size_t = 1000000) {
  input receive: size_t
  input start: bool
  output send: size_t
  output finished: bool
  state pingsLeft: size_t = count
  input serve_in: int
  output serve_out: int

  reaction(start, serve_in) -> send {=
    lf_set(send, self->pingsLeft--);
  =}

  reaction(receive) -> serve_out, finished {=
    if (self->pingsLeft > 0) {
        lf_set(serve_out, 0);
    } else {
        // reset pingsLeft for next iteration
        self->pingsLeft = self->count;
        lf_set(finished, true);
    }
  =}
}

reactor Pong(expected: size_t = 1000000) {
  input receive: size_t
  output send: size_t
  input finish: bool
  state count: size_t = 0

  reaction(receive) -> send {=
    self->count++;
    // lf_print("Received %d", receive->value);
    lf_set(send, receive->value);
  =}

  reaction(finish) {=
    if (self->count != self->expected) {
        lf_print_error_and_exit("Pong expected to receive %d inputs, but it received %d.\n",
            self->expected, self->count
        );
        exit(1);
    }
    printf("Success.\n");
    self->count = 0;
  =}
}

main reactor(count: size_t = 1000000) {
  ping = new WrapperPing(count=count)
  pong = new Pong(expected=count)

  ping.finished -> pong.finish
  ping.send -> pong.receive
  pong.send -> ping.receive

  reaction(startup) -> ping.start {=
    lf_print("This is the PingPong benchmark.");
    lf_set(ping.start, NULL);
  =}
}

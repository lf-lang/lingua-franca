target C {
  timeout: 1 sec,
  coordination: decentralized
}

reactor Count {
  state count: int = 1
  output out: int
  logical action loop

  reaction(startup) -> loop {=
    lf_schedule(loop, 0);
  =}

  reaction(loop) -> out {=
    if (self->count < 20) {
      lf_set(out, self->count++);
      lf_schedule(loop, 0);
    }
  =}
}

reactor Print {
  input in: int
  state c: int = 1
  state checks: int = 0

  logical action loop

  reaction(startup) -> loop {=
    lf_schedule(loop, 0);
  =}

  reaction(in) {=
    interval_t elapsed_time = lf_time_logical_elapsed();
    lf_print("At time %lld, received %d", elapsed_time, in->value);
    if (in->value != self->c) {
      lf_print_error_and_exit("Expected to receive %d.", self->c);
    }
    self->c++;
  =} STP(100 msec) {=
    lf_print_error_and_exit("STP violation. This should not happen because the STP offset is large.");
  =}

  reaction(loop) {=
    lf_print("checking self.checks, which is now %d...", self->checks);
    if (self->checks++ > 10) {
      lf_request_stop();
    } else {
      lf_schedule(loop, 0);
    }
  =}
}

federated reactor {
  c = new Count()
  p = new Print()
  c.out -> p.in after 0
}

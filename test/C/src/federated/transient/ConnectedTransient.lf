target C {
    timeout: 10s,
    tracing: true,
    threading: true 
}

reactor Up(period:time = 2s) {
    output out: int
    timer t(0, period)
    state count: int = 0
    reaction(t) -> out {=
        lf_set(out, self->count);
        lf_print("Count is = %d", self->count);
        self->count++;
    =}
}

reactor Middle {
    input in1: int
    input in2: int
    output out: int
    state count: int=0
    reaction(in1) -> out {=
        self->count += in1->value;
        lf_set(out, self->count);
        lf_print("Sending %d", self->count);
    =}
    reaction(in2) -> out {=
        self->count += in2->value;
        lf_set(out, self->count);
        lf_print("Sending %d", self->count);
    =}
}

reactor Down{
    input in: int
    reaction(in) {=
        lf_print("Received %d at logical time %lld", in-> value, lf_time_logical_elapsed());
    =}
}

federated reactor {
    up1 = new Up(period = 2s)
    up2 = new Up(period = 1s)
    @transient
    mid = new Middle()
    down = new Down()

    // Connections
    up1.out -> mid.in1
    up2.out -> mid.in2
    mid.out -> down.in
}
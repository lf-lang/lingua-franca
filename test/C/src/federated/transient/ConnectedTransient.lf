target C {
    timeout: 20 s,
    tracing: true
}

reactor Up(period: time = 2 s) {
    output out: int
    timer t(0, period)
    state count: int = 0

    reaction(t) -> out {=
        lf_set(out, self->count);
        lf_print("Count is = %d at (%lld, %ld)", self->count, lf_time_logical_elapsed(), lf_tag().microstep);
        self->count++;
    =}
}

reactor Middle {
    input in1: int
    input in2: int
    output out: int
    state count: int = 0

    reaction(in1) -> out {=
        self->count += in1->value;
        lf_set(out, self->count);
        lf_print("IN1 :: Sending %d at (%lld, %ld)", self->count, lf_time_logical_elapsed(), lf_tag().microstep);
        // lf_print("IN1 (New version):: Sending %d at (%lld, %ld)", self->count, lf_time_logical_elapsed(), lf_tag().microstep);
    =}

    reaction(in2) -> out {=
        self->count += in2->value;
        lf_set(out, self->count);
        lf_print("IN2 :: Sending %d at (%lld, %ld)", self->count, lf_time_logical_elapsed(), lf_tag().microstep);
        // lf_print("IN2 (New version):: Sending %d at (%lld, %ld)", self->count, lf_time_logical_elapsed(), lf_tag().microstep);
    =}
}

reactor Down {
    timer t(2 s, 300 ms)
    input in: int

    reaction(t) {=
        lf_print("Timer :: at (%lld, %ld)", lf_time_logical_elapsed(), lf_tag().microstep);
    =}

    reaction(in) {=
        lf_print("Received %d at (%lld, %ld)", in->value, lf_time_logical_elapsed(), lf_tag().microstep);
    =}
}

federated reactor {
    up1 = new Up(period = 2 s)
    up2 = new Up(period = 1 s)
    @transient
    mid = new Middle()
    down = new Down()

    up1.out -> mid.in1  // Connections
    up2.out -> mid.in2
    mid.out -> down.in
}

/**
 * This lf program tests if a transient federate corretly leaves then joins the federation. It also
 * tests if the transient's downstream executes as expected, that is it received correct TAGs,
 * regardless of the transient being absent or present.
 */
target C {
  timeout: 2 s
}

preamble {=
  #include <stdlib.h>
  #include <string.h>
=}

/** Persistent federate that is responsible for lauching the transient at logical time 1 s */
reactor TransientExec {
  logical action a

  reaction(startup) -> a {= lf_schedule(a, SEC(1)); =}

  reaction(a) {=
    // Construct the command to launch the transient federate
    char mid_launch_cmd[512];
    sprintf(mid_launch_cmd,
        "%s/federate__mid -i %s",
        lf_get_federates_bin_directory(),
        lf_get_federation_id()
    );

    int status = system(mid_launch_cmd);

    // Exit if error
    if (status == 0) {
        lf_print("Successfully launched federate__mid.");
    } else {
        lf_print_error_and_exit("Unable to launch federate__mid.");
    }
  =}
}

/**
 * Persistent federate, upstream of the transient. It outputs 0, 1, 2, 3, 4 at logical times 0, 500,
 * 1000, 1500 and 2000.
 */
reactor Up {
  output out: int
  timer t(0, 500 msec)
  state count: int = 0

  reaction(t) -> out {=
    lf_set(out, self->count);
    lf_print("Count is = %d at " PRINTF_TAG, self->count, lf_time_logical_elapsed(), lf_tag().microstep);
    self->count++;
  =}
}

/**
 * Transient federate that forwards what it receives from Up, after augmenting it with its own count
 * values. It will execute twice during the lifetime of the federation. In the first execution, it
 * will spontaneously stop after the second reaction to in. Then, it will be launched again by
 * TransientExec at logical time 1 s, to resign at the stop_tag of the federation. Middle notifies
 * Down that it joined and and sends its offset w.r.t the start time of the federation.
 */
reactor Middle {
  input in: int
  output out: int
  output out_joined: instant_t

  state count: int = 0

  timer t(0, 250 msec)

  reaction(startup) -> out_joined {=
    int first_join = (lf_get_effective_start_time() == lf_get_start_time());

    if (first_join == 1) {
      lf_print("Mid is joining during the startup phase.");
    } else {
      lf_print("Mid is joining after the startup phase and the offset is: " PRINTF_TIME" ns.",
          lf_get_effective_start_time() - lf_get_start_time());
    }

    lf_set(out_joined, lf_get_effective_start_time() - lf_get_start_time());
  =}

  reaction(t) {=
    lf_print("Mid reacting to t at federation elapsed logical time " PRINTF_TIME " and local \
          elapsed logical time " PRINTF_TIME,
          lf_time_logical_elapsed(),
          lf_time_logical() - lf_get_effective_start_time());
  =}

  reaction(in) -> out {=
    self->count += 100;
    int to_send = self->count + in->value;
    lf_set(out, to_send);
    // If this is the first execution of Middle, then it will spontaneously stop after two reactions
    if (
      (self->count == 200) &&
      (lf_get_effective_start_time() == lf_get_start_time())
    ) {
      lf_stop();
    }
  =}
}

/**
 * Persistent federate, which is downstream of the transient. It has to keep reacting to its
 * internal timer and also to inputs from the tansient, if any.
 */
reactor Down {
  timer t(0, 500 ms)

  input in: int
  input in_joined: instant_t

  state count: int = 0
  state received: int = 0
  state num_joined: int = 0
  state join_offset_1: instant_t = 0
  state join_offset_2: instant_t = 0

  reaction(t) {=
    self->count += 1000;
        lf_print("Count of Down is: %d at " PRINTF_TIME, self->count, lf_time_logical_elapsed()/1000000);
  =}

  reaction(in) {=
    self->received = in->value;
    lf_print("Received of Down is: %d at " PRINTF_TIME, self->received, lf_time_logical_elapsed()/1000000);
  =}

  reaction(in_joined) {=
    self->num_joined++;
    if (self->num_joined == 1) {
      self->join_offset_1 = in_joined->value;
    } else {
      self->join_offset_2 = in_joined->value;
    }
  =}

  reaction(shutdown) {=
    // Check that the TAG have been successfully issued to Down
    if (self->count != 5000) {
      lf_print_error_and_exit("Federate's timer failed to react.");
    }

    // Check that Middle have joined 2 times
    if (self->num_joined != 2 || self->join_offset_2 <= self->join_offset_1) {
      lf_print_error_and_exit("Transient federate Mid did not execute twice!");
    }

    // Check that Middle have reacted correctly
    if (self->received < 102) {
      lf_print_error_and_exit("Transient federate Mid did not execute and pass values from up corretly! Expected >= 102, but have: %d.", self->received);
    }
  =}
}

federated reactor {
  up = new Up()
  down = new Down()
  // Important note: since mid is instantiated before persistent federate midExec,
  // it will join at the startup phase, making its effective start time equal to the federation
  // start time. Defining mid at the end will break up the test described above.
  @transient
  mid = new Middle()
  midExec = new TransientExec()

  up.out -> mid.in  // Connections
  mid.out_joined -> down.in_joined
  mid.out -> down.in
}

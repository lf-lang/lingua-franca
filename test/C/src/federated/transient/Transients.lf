/**
 * This tests if a transient corretly leaves then joins the federation. It also tests if the
 * transient's downstream executes as expected that is it received correct TAG, regardless if the
 * transient being absent or present.
 */
target C {
  timeout: 2 s,
  tracing: true
}

preamble {=
  #include <stdlib.h>
  #include <string.h>
=}

/** Persistent federate that is responsible for lauching the transient at logical time 1400ms */
reactor TransientExec {
  timer t(1400 msec, 2 sec)

  reaction(t) {=
    // Construct the command to launch the transient federate
    char mid_launch_cmd[512] = lf_get_federates_bin_directory();
    strcat(mid_launch_cmd, "/federate__mid -i ");
    strcat(mid_launch_cmd, lf_get_federation_id());
    // Execute the command
    int status = system(mid_launch_cmd);
    // Exit if error
    if (status == 0) {
        lf_print("Successfully launched federate__mid.");
    } else {
        lf_print_error_and_exit("Unable to launch federate__mid.");
    }
  =}
}

/**
 * Persistent federate, upstream of the transient. It outputs 0, 1, 2, 3, 4 at logical times 0, 500,
 * 1000, 1500 and 2000.
 */
reactor Up {
  output out: int
  timer t(0, 500 msec)
  state count: int = 0

  reaction(t) -> out {=
    lf_set(out, self->count);
    lf_print("Count is = %d at "PRINTF_TAG, self->count, lf_time_logical_elapsed(), lf_tag().microstep);
    self->count++;
  =}
}

/**
 * Transient federate that forwards what it receives from Up, after augmenting it with its own count
 * values. It will execute twice during the lifetime of the federation. In the first execution, it
 * will spontaneously stop at logical time 800 ms. Then it will be launched again by TransientExec
 * at logical time 1400 ms, to resign at the stop_tag of the fderation. In both executions, Middle
 * will react twice to the incoming input from Up.
 */
reactor Middle {
  input in: int
  output out: int
  state count: int = 0

  timer t(800 msec, 2 s)

  reaction(in) -> out {=
    self->count += 100;
    int to_send = self->count + in->value;
    lf_set(out, to_send);
  =}

  reaction(t) {=
    // Middle will spontaneously stop at 800 msec
    lf_stop();
  =}
}

/**
 * Persistent federate, which is downstream of the transient. It has to keep reacting to its
 * internal timer and also to inputs from the tarnsient, if any.
 */
reactor Down {
  timer t(0, 500 ms)

  input in: int

  state count: int = 0
  state received: int = 0

  reaction(t) {=
    self->count += 1000;
        lf_print("Count of Down is: %d at "PRINTF_TIME, self->count, lf_time_logical_elapsed()/1000000);
  =}

  reaction(in) {=
    self->received = in->value;
    lf_print("Received of Down is: %d at "PRINTF_TIME, self->received, lf_time_logical_elapsed()/1000000);
  =}

  reaction(shutdown) {=
    // Check that the TAG have been successfully issued to Down
    if (self->count != 5000) {
        lf_print_error_and_exit("Federate's timer failed to react.");
    }

    // Check that Middle have joined during the last two periods of Up
    if (self->received != 204) {
        lf_print_error_and_exit("Wrong passed values form Up and Mid! Received %d while expecting 204.", self->received);
    }
  =}
}

federated reactor {
  up = new Up()
  down = new Down()
  @transient
  mid = new Middle()
  midExec = new TransientExec()

  up.out -> mid.in  // Connections
  mid.out -> down.in
}

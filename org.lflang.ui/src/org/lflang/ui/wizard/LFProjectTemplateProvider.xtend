/*
 * generated by Xtext 2.25.0
 */
package org.lflang.ui.wizard

import org.eclipse.core.runtime.Status
import org.eclipse.jdt.core.JavaCore
import org.eclipse.xtext.ui.XtextProjectHelper
import org.eclipse.xtext.ui.util.PluginProjectFactory
import org.eclipse.xtext.ui.wizard.template.IProjectGenerator
import org.eclipse.xtext.ui.wizard.template.IProjectTemplateProvider
import org.eclipse.xtext.ui.wizard.template.ProjectTemplate

import static org.eclipse.core.runtime.IStatus.*

/**
 * Create a list with all project templates to be shown in the template new project wizard.
 * 
 * Each template is able to generate one or more projects. Each project can be configured such that any number of files are included.
 */
class LFProjectTemplateProvider implements IProjectTemplateProvider {
	override getProjectTemplates() {
		#[new HelloWorldProject, new InteractiveProject, new WebServerProject, new ReflexGameProject, new ParallelProject, new PipelineProject, new FederatedProject]
	}
}

@ProjectTemplate(label="Pipeline", icon="project_template.png", description="<p><b>Pipeline</b></p>
    <p>Basic pipeline pattern where a periodic source feeds a chain of reactors that can all execute in parallel at each logical time step.</p>")
    final class PipelineProject {
        // val advanced = check("Advanced:", false)
        //val config = group("Configuration")
        //val target = combo("Target:", #["C"], "The target language to compile down to", config)


        override generateProjects(IProjectGenerator generator) {
            generator.generate(new PluginProjectFactory => [
                projectName = projectInfo.projectName
                location = projectInfo.locationPath
                projectNatures += #[XtextProjectHelper.NATURE_ID]
                builderIds += #[XtextProjectHelper.BUILDER_ID]
                folders += #["src"]
                addFile("src/Pipeline.lf", '''
                    /**
                     * Basic pipeline pattern where a periodic source feeds
                     * a chain of reactors that can all execute in parallel
                     * at each logical time step.
                     * 
                     * The threads argument specifies the number of worker
                     * threads, which enables the reactors in the chain to
                     * execute on multiple cores simultaneously.
                     * 
                     * This uses the TakeTime reactor to perform computation. 
                     * If you reduce the number of worker threads to 1, the 
                     * execution time will be approximately four times as long.
                     * 
                     * @author Edward A. Lee
                     * @author Marten Lohstroh
                     */
                    target C {
                        threads: 4,
                    }
                     
                    /**
                     * Send counting sequence periodically.
                     * 
                     * @param offset The starting time.
                     * @param period The period.
                     * @param initial The first output.
                     * @param increment The increment between outputs
                     */
                    reactor SendCount(
                        offset:time(0), 
                        period:time(1 sec),
                        initial:int(0),
                        increment:int(1)
                    ) {
                        state count:int(initial);
                        output out:int;
                        timer t(offset, period);
                        reaction(t) -> out {=
                            SET(out, self->count);
                            self->count += self->increment;
                        =}
                    }
                    
                    /**
                     * Receive an input and report the elapsed logical tag
                     * and the value of the input. Request stop when the 10th
                     * value has been received.
                     */
                    reactor Receive {
                        input in:int;
                        reaction(in) {=
                            info_print("At elapsed tag (%lld, %d), received %d.",
                                get_elapsed_logical_time(), get_microstep(),
                                in->value
                            );
                            if (in->value >= 10) {
                                request_stop();
                            }
                        =}
                    }
                    
                    /**
                     * When triggered, take the specified amount of physical time
                     * before outputting the value of the trigger.
                     * 
                     * @param approximate_time The approximate amount of physical 
                     *  time to take for each input.
                     * 
                     * @input in A triggering input.
                     * 
                     * @output out The triggering input. 
                     */
                    reactor TakeTime(
                        approximate_time:time(100 msec)
                    ) {
                        input in:int;
                        output out:int;
                        reaction(in) -> out {=
                            instant_t start_time = get_physical_time();
                            while (get_physical_time() < start_time + self->approximate_time) {
                                // Do nothing.
                            }
                            SET(out, in->value);
                        =}
                    }
                    
                    main reactor {
                        r0 = new SendCount(period = 100 msec);
                        rp = new[4] TakeTime(approximate_time = 100 msec);
                        r5 = new Receive();
                        // Uncomment the "after" clause to expose parallelism.
                        r0.out, rp.out -> rp.in, r5.in // after 100 msec; 
                    }
                ''')
            ])
        }
    
    }

@ProjectTemplate(label="Federated", icon="project_template.png", description="<p><b>Federated</b></p>
    <p>A federated \"Hello World\" program.</p>")
    final class FederatedProject {
        // val advanced = check("Advanced:", false)
        //val config = group("Configuration")
        //val target = combo("Target:", #["C"], "The target language to compile down to", config)

        override generateProjects(IProjectGenerator generator) {
            generator.generate(new PluginProjectFactory => [
                projectName = projectInfo.projectName
                location = projectInfo.locationPath
                projectNatures += #[XtextProjectHelper.NATURE_ID]
                builderIds += #[XtextProjectHelper.BUILDER_ID]
                folders += #["src"]
                addFile("src/HelloWorld.lf", '''
                    /**
                     * Distributed LF program where a MessageGenerator creates a string
                     * message that is sent via the RTI (runtime infrastructure) to a
                     * receiver that prints the message.
                     * 
                     * The code generator generates three programs:
                     * 
                     * * bin/DistributedHelloWorld: A script that launches the other three
                     *   programs on localhost.  Run this program.
                     *  
                     * * bin/DistributedHelloWorld_source: The program that produces the sequence
                     *   of messages.
                     * 
                     * * bin/DistributedHelloWorld_print: The program that produces the sequence
                     *   of messages.
                     * 
                     * To run this manually, you can start the RTI and then each of the last 
                     * two programs. They will synchronize the start time and run for 10 seconds.
                     * 
                     * Note: The RTI is a separate program that has to be installed separately.
                     *  See https://github.com/lf-lang/reactor-c/tree/main/core/federated/RTI
                     * 
                     * @author Edward A. Lee
                     */
                    target C {
                        timeout: 10 secs
                    };
                    
                    /**
                     * Reactor that generates a sequence of messages, one per second.
                     * The message will be a string consisting of a prefix string followed
                     * by a count.
                     * @param prefix The prefix string.
                     * @output message The message.
                     */
                    reactor MessageGenerator(prefix:string("")) {
                        // Output type char* instead of string is used for dynamically
                        // allocated character arrays (as opposed to static constant strings).
                        output message:char*;
                        state count:int(1);
                        // Send first message after 1 sec so that the startup reactions
                        // do not factor into the transport time measurement on the first message.
                        timer t(1 sec, 1 sec);
                        reaction(t) -> message {=
                            // With NULL, 0 arguments, snprintf tells us how many bytes are needed.
                            // Add one for the null terminator.
                            int length = snprintf(NULL, 0, "%s %d", self->prefix, self->count) + 1;
                            // Dynamically allocate memory for the output.
                            SET_NEW_ARRAY(message, length);
                            // Populate the output string and increment the count.
                            snprintf(message->value, length, "%s %d", self->prefix, self->count++);
                    
                            tag_t tag = get_current_tag();
                            info_print("At (elapsed) logical tag (%lld, %u), source sends message: %s",
                                tag.time - start_time, tag.microstep,
                                message->value
                            );
                        =}
                    }
                    
                    /**
                     * Reactor that prints the current tag and an incoming string.
                     *
                     * @input message The message.
                     */
                    reactor PrintMessage {
                        input message:char*;
                        reaction(message) {=
                            tag_t tag = get_current_tag();
                            info_print("At (elapsed) logical tag (%lld, %u), print receives: %s",
                                tag.time - start_time, tag.microstep,
                                message->value
                            );
                        =}
                    }
                    
                    federated reactor HelloWorld {
                        source = new MessageGenerator(prefix = "Hello World");
                        print = new PrintMessage();
                        source.message -> print.message;
                    }
                ''')
            ])
        }
    
    }


@ProjectTemplate(label="Parallel", icon="project_template.png", description="<p><b>Parallel</b></p>
    <p>A simple fork-join pattern that exploits parallelism.</p>")
    final class ParallelProject {
        // val advanced = check("Advanced:", false)
        //val config = group("Configuration")
        //val target = combo("Target:", #["C"], "The target language to compile down to", config)


        override generateProjects(IProjectGenerator generator) {
            generator.generate(new PluginProjectFactory => [
                projectName = projectInfo.projectName
                location = projectInfo.locationPath
                projectNatures += #[XtextProjectHelper.NATURE_ID]
                builderIds += #[XtextProjectHelper.BUILDER_ID]
                folders += #["src"]
                addFile("src/Parallel.lf", '''
                    /**
                      * Each instance of TakeTime takes 200 ms wall clock time to
                      * transport the input to the output. Four of them are
                      * instantiated. Note that without parallel execution, there is 
                      * no way this program can keep up with real time since in every
                      * 200 msec cycle it has 800 msec of work to do. Given 4 threads, 
                      * however, this program can complete 800 msec of work in about
                      * 225 msec. 
                      */
                    target C {
                        timeout: 2 sec,
                        threads: 1, // Change to 4 to see speed up.
                    };
                    reactor Source {
                            timer t(0, 200 msec);
                            output out:int;
                            state s:int(0);
                            reaction(t) -> out {=
                                    SET(out, self->s);
                                    self->s++;
                            =}
                    }
                    reactor TakeTime {
                            input in:int;
                            output out:int;
                            reaction(in) -> out {=
                                    struct timespec sleep_time = {(time_t) 0, (long)200000000};
                                    struct timespec remaining_time;
                                    nanosleep(&sleep_time, &remaining_time);
                                    int offset = 0;
                                    for (int i = 0; i < 100000000; i++) {
                                        offset++;
                                    }
                                    SET(out, in->value + offset);
                            =}
                    }
                    reactor Destination(width:int(4)) {
                            state s:int(400000000);
                            input[width] in:int;
                            reaction(in) {=
                                    int sum = 0;
                                    for (int i = 0; i < in_width; i++) {
                                sum += in[i]->value;
                            }
                                    printf("Sum of received: %d.\n", sum);
                                    if (sum != self->s) {
                                            printf("ERROR: Expected %d.\n", self->s);
                                            exit(1);
                                    }
                                    self->s += in_width;
                            =}
                    }
                    main reactor Parallel(width:int(4)) {
                            a = new Source();
                            t = new[width] TakeTime();
                            (a.out)+ -> t.in;
                        b = new Destination(width = width);
                            t.out -> b.in;
                    }                    
                    '''
                )
            ])
        }
    
    }


@ProjectTemplate(label="Hello World", icon="project_template.png", description="<p><b>Hello World</b></p>
<p>Print \"Hello world!\" in a target language of choice.</p>")
final class HelloWorldProject {
	//val advanced = check("Advanced:", false)
	val config = group("Configuration")
	val target = combo("Target:", #["C", "C++", "Python", "TypeScript"], "The target language to compile down to", config)
	//val path = text("Package:", "mydsl", "The package path to place the files in", advancedGroup)
    //target.enabled = true
    
//	override protected updateVariables() {
//		name.enabled = advanced.value
//		path.enabled = advanced.value
//		if (!advanced.value) {
//			name.value = "Xtext"
//			path.value = "lf"
//		}
//	}

//	override protected validate() {
//		if (path.value.matches('[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*'))
//			null
//		else
//			new Status(ERROR, "Wizard", "'" + path + "' is not a valid package name")
//	}

	override generateProjects(IProjectGenerator generator) {
		generator.generate(new PluginProjectFactory => [
			projectName = projectInfo.projectName
			location = projectInfo.locationPath
			projectNatures += #[XtextProjectHelper.NATURE_ID] // JavaCore.NATURE_ID, "org.eclipse.pde.PluginNature", 
			builderIds += #[XtextProjectHelper.BUILDER_ID] // JavaCore.BUILDER_ID, 
			folders += "src"
			addFile('''src/HelloWorld.lf''', '''
				/**
				 * Print "Hello World!" in «target».
				 */
				«IF target.value.equals("C")»
				target C
				
				main reactor {
				    reaction(startup) {=
				        // Using a thread-safe print function provided by the runtime.
				        info_print("Hello World!");
				    =}
				}
				«ELSEIF target.value.equals("C++")»
                target Cpp
                
                main reactor {
                    reaction(startup) {=
                        std::cout << "Hello World!";
                    =}
                }
                «ELSEIF target.value.equals("Python")»
                target Python
                
                main reactor {
                    reaction(startup) {=
                        print("Hello World!")
                    =}
                }
                «ELSEIF target.value.equals("TypeScript")»
                target TypeScript
                
                main reactor {
                    reaction(startup) {=
                        console.log("Hello World!")
                    =}
                }
				«ENDIF»
			''')
		])
	}
}

@ProjectTemplate(label="Interactive", icon="project_template.png", description="<p><b>Interactive</b></p>
<p>Simulate sensor input through key strokes.</p>")
final class InteractiveProject {
    //val advanced = check("Advanced:", false)
    val config = group("Configuration")
    val target = combo("Target:", #["C"], "The target language to compile down to", config)
    
    override generateProjects(IProjectGenerator generator) {
        generator.generate(new PluginProjectFactory => [
            projectName = projectInfo.projectName
            location = projectInfo.locationPath
            projectNatures += #[XtextProjectHelper.NATURE_ID]
            builderIds += #[XtextProjectHelper.BUILDER_ID] 
            folders += #["src", "src/include"]
            addFile("src/Interactive.lf", '''
                /**
                 * Simple demonstration of the sensor simulator (used in the Rhythm examples).
                 * This has no audio output, but just tests the ncurses interface.
                 */
                target «target» {
                    threads: 2,
                    cmake-include: ["ncurses-cmake-extension.txt", "sensor_simulator.cmake"], // Adds support for ncurses
                    files: [
                            "/lib/C/util/sensor_simulator.c", 
                            "/lib/C/util/sensor_simulator.h",
                            "/lib/C/util/sensor_simulator.cmake",
                            "include/ncurses-cmake-extension.txt"
                        ]
                };
                preamble {=
                    #include "sensor_simulator.h"
                    char* messages[] = {"Hello", "World"};
                    int num_messages = 2;
                =}
                main reactor {
                    timer t(0, 1 sec);
                    timer r(0, 2 sec);
                    physical action key:char*;
                    reaction(startup) -> key {=
                        info_print("Starting sensor simulator.");
                        start_sensor_simulator(messages, num_messages, 16, NULL, LOG_LEVEL_INFO);
                        register_sensor_key('\0', key);
                   =}
                    reaction(t) {=
                        show_tick("*");
                    =}
                    reaction(r) {=
                        info_print("Elapsed logical time: %lld.", get_elapsed_logical_time());
                        show_tick(".");
                    =}
                    reaction(key) {=
                        info_print("You typed '%s' at elapsed time %lld.", key->value, get_elapsed_logical_time());
                    =}
                }
            ''')
            addFile("src/include/ncurses-cmake-extension.txt", '''
                find_package(Curses REQUIRED) # Finds the lncurses library
                include_directories(${CURSES_INCLUDE_DIR}) # "The include directories needed to use Curses"
                target_link_libraries( ${LF_MAIN_TARGET} ${CURSES_LIBRARIES} ) # Links the Curses library
            ''')
        ])
    }
}

@ProjectTemplate(label="WebServer", icon="project_template.png", description="<p><b>Web Server</b></p>
<p>A simple web server implemented using TypeScript.</p>")
final class WebServerProject {
    //val advanced = check("Advanced:", false)
    val config = group("Configuration")
    val target = combo("Target:", #["TypeScript"], "The target language to compile down to", config)
    
    override generateProjects(IProjectGenerator generator) {
        generator.generate(new PluginProjectFactory => [
            projectName = projectInfo.projectName
            location = projectInfo.locationPath
            projectNatures += #[XtextProjectHelper.NATURE_ID]
            builderIds += #[XtextProjectHelper.BUILDER_ID] 
            folders += #["src"]
            addFile("src/WebServer.lf", '''
                target «target» {
                    keepalive : true
                };
                
                main reactor {
                    preamble {=
                        import * as http from "http"
                    =}
                    state server:{=http.Server | undefined=}({=undefined=});
                    physical action serverRequest:{= [http.IncomingMessage, http.ServerResponse] =};
                    reaction (startup) -> serverRequest {=
                        let options = {};
                        server = http.createServer(options, (req : http.IncomingMessage, res : http.ServerResponse) => {
                            // Generally, browsers make two requests; the first is for favicon.ico.
                            // See https://stackoverflow.com/questions/11961902/nodejs-http-createserver-seems-to-call-twice
                            if (req.url != "/favicon.ico") {
                                actions.serverRequest.schedule(0, [req, res])
                            }
                        }).listen(8000);
                        console.log("Started web server at http://localhost:8000/")
                    =}
                    reaction (serverRequest) {=
                        let requestArray = serverRequest;
                        if (requestArray) {
                            let req = requestArray[0];
                            let res = requestArray[1];
                            res.writeHead(200);
                            res.end("Hello world!\n");
                        }
                    =}
                    reaction (shutdown) {=
                        if (server) {
                            server.close();
                        }
                    =} 
                }
            ''')
        ])
    }
}

@ProjectTemplate(label="ReflexGame", icon="project_template.png", description="<p><b>ReflexGame</b></p>
<p>A simple reflex game.</p>")
final class ReflexGameProject {
    //val advanced = check("Advanced:", false)
    val config = group("Configuration")
    val target = combo("Target:", #["C", "Python"], "The target language to compile down to", config)
    
    override generateProjects(IProjectGenerator generator) {
        generator.generate(new PluginProjectFactory => [
            projectName = projectInfo.projectName
            location = projectInfo.locationPath
            projectNatures += #[XtextProjectHelper.NATURE_ID]
            builderIds += #[XtextProjectHelper.BUILDER_ID] 
            folders += #["src"]
            if (target.value.equals("C")) {
                
                addFile("src/ReflexGame.lf", '''
                    /**
                     * This example illustrates the use of logical and physical actions,
                     * asynchronous external inputs, the use of startup and shutdown
                     * reactions, and the use of actions with values.
                     * 
                     * The example is fashioned after an Esterel implementation given by
                     * Berry and Gonthier in "The ESTEREL synchronous programming language:
                     * design, semantics, implementation," Science of Computer Programming,
                     * 19(2) pp. 87-152, Nov. 1992, DOI: 10.1016/0167-6423(92)90005-V.
                     * 
                     * @author Edward A. Lee
                     * @author Marten Lohstroh
                     */
                    target C {
                        threads: 1,
                        keepalive: true
                    };
                    /**
                     * Produce a counting sequence at random times with a minimum
                     * and maximum time between outputs specified as parameters.
                     * 
                     * @param min_time The minimum time between outputs.
                     * @param max_time The maximum time between outputs.
                     */
                    reactor RandomSource(min_time:time(2 sec), max_time:time(8 sec)) {
                        preamble {=
                            // Generate a random additional delay over the minimum. 
                            // Assume millisecond precision is enough.
                            interval_t additional_time(interval_t min_time, interval_t max_time) {
                                int interval_in_msec = (max_time - min_time) / MSEC(1);
                                return (rand() % interval_in_msec) * MSEC(1);
                            }
                        =}
                        input another:int;
                        output out:int;
                        logical action prompt(min_time);
                        state count:int(0);
                        
                        reaction(startup) -> prompt {=
                            printf("***********************************************\n");
                            printf("Watch for the prompt, then hit Return or Enter.\n");
                            printf("Type Control-D (EOF) to quit.\n\n");
                            
                            // Random number functions are part of stdlib.h, which is included by reactor.h.
                            // Set a seed for random number generation based on the current time.
                            srand(time(0));
                            
                            // Schedule the first event.
                            schedule(prompt, additional_time(0, self->max_time - self->min_time));
                        =}
                        reaction(prompt) -> out {=
                            self->count++;
                            printf("%d. Hit Return or Enter!", self->count);
                            fflush(stdout);
                            SET(out, self->count);
                        =}
                        reaction(another) -> prompt {=
                            // Schedule the next event.
                            schedule(prompt, additional_time(0, self->max_time - self->min_time));
                        =}
                    }
                    /**
                     * Upon receiving a prompt, record the time of the prompt,
                     * then listen for user input. When the user hits return,
                     * then schedule a physical action that records the time
                     * of this event and then report the response time.
                     */
                    reactor GetUserInput {
                        preamble {=
                            // Thread to read input characters until an EOF is received.
                            // Each time a newline is received, schedule a user_response action.
                            void* read_input(void* user_response) {
                                int c;
                                while(1) {
                                    while((c = getchar()) != '\n') {
                                        if (c == EOF) break;
                                    }
                                    schedule_copy(user_response, 0, &c, 1);
                                    if (c == EOF) break;
                                }
                                return NULL;
                            }
                        =}
                    
                        physical action user_response:char;
                        state prompt_time:time(0);
                        state total_time_in_ms:int(0);
                        state count:int(0);
                        
                        input prompt:int;
                        output another:int;
                        
                        reaction(startup) -> user_response {=
                            // Start the thread that listens for Enter or Return.
                            lf_thread_t thread_id;
                            lf_thread_create(&thread_id, &read_input, user_response);        
                        =}
                        
                        reaction(prompt) {=
                            self->prompt_time = get_physical_time();
                        =}
                        
                        reaction(user_response) -> another {=
                            if (user_response->value == EOF) {
                                request_stop();
                                return;
                            }
                            // If the prompt_time is 0, then the user is cheating and
                            // hitting return before being prompted.
                            if (self->prompt_time == 0LL) {
                                printf("YOU CHEATED!\n");
                                request_stop();
                            } else {
                                int time_in_ms = (get_logical_time() - self->prompt_time) / 1000000LL;
                                printf("Response time in milliseconds: %d\n", time_in_ms);
                                self->count++;
                                self->total_time_in_ms += time_in_ms;
                                // Reset the prompt_time to indicate that there is no new prompt.
                                self->prompt_time = 0LL;
                                // Trigger another prompt.
                                SET(another, 42);
                            }
                        =}
                        
                        reaction(shutdown) {=
                            if (self->count > 0) {
                                printf("\n**** Average response time: %d.\n", self->total_time_in_ms/self->count);
                            } else {
                                printf("\n**** No attempts.\n");
                            }
                        =}
                    }
                    main reactor ReflexGame {
                        p = new RandomSource();
                        g = new GetUserInput();
                        p.out -> g.prompt;
                        g.another -> p.another;
                    }
                ''')
            } else if (target.value.equals("Python")) {
                addFile("src/ReflexGame.lf", 
                    '''
                    target Python {
                        keepalive: true,
                        files: [gui.py]
                    }
                    
                    reactor RandomSource(min_time(2 sec), max_time(8 sec)) {
                        preamble {=
                            import random
                            def additional_time(self, min_time, max_time):
                                return self.random.randint(min_time, max_time)
                        =}
                        input another;
                        output out;
                        logical action prompt(min_time);
                        state count(0);
                        reaction(startup) {=
                            self.random.seed()
                        =}
                    
                        reaction(prompt) -> out {=
                            self.count += 1
                            out.set(self.count)
                        =}
                    
                        reaction(another) -> prompt {=
                            # schedule a prompt event 
                            prompt.schedule(self.additional_time(0, self.max_time - self.min_time))
                        =}
                    }
                    
                    /*
                     * Receives key presses from the pygame process. 
                     */
                    reactor GetUserInput {
                        preamble {=
                            import threading
                            def listen_for_input(self, user_response):
                                while 1:
                                    try:
                                        c = self.user_input.recv()
                                    except EOFError:
                                        request_stop()
                                        return
                                    # Each time a key press is received, schedule a user_response event 
                                    user_response.schedule(0, c)
                        =}
                        
                        physical action user_response;
                        state user_input({=None=}); # multiprocessing.connection.PipeConnection
                        input user_input_pipe_init;
                        output user_input;
                        
                        reaction(user_input_pipe_init) -> user_response {=
                            # Stores the Pipe object that will be used to receive key presses from
                            #     the pygame process
                            self.user_input = user_input_pipe_init.value
                            
                            # Starts the thread that receives key presses from the pygame process
                            t = self.threading.Thread(target=self.listen_for_input, args=(user_response, ))
                            t.start()
                        =}
                        
                        reaction(user_response) -> user_input {=
                            user_input.set(user_response.value)
                        =}
                    }
                    
                    
                    /*
                     * Sends graphics updates to the pygame process. 
                     */
                    reactor UpdateGraphics {
                        input prompt;
                        input update_graphics_pipe_init;
                        input user_input;
                        output another;
                        state update_graphics({=None=}); # multiprocessing.connection.PipeConnection
                        state first({=True=})
                        state count(0);
                        state total_time_in_ms(0);
                        state prompt_time(0);
                        
                        reaction(update_graphics_pipe_init) {=
                            # Stores the Pipe object that will be used to send graphics update to
                            #     the pygame process 
                            self.update_graphics = update_graphics_pipe_init.value
                            
                            # Displays an introductory prompt to the user. 
                            self.update_graphics.send(((0,0,0),             # Color of background
                                                       (255, 255, 255),     # Color of text
                                                       "Press any key to begin", 
                                                       "To end the game, you can either: ", 
                                                       "1. Close this window", 
                                                       "2. Press CTRL+C in the Terminal", 
                                                       "3. Press any key before the prompt shows up."))
                        =}
                        
                        reaction(prompt) {=
                            # Ask the user for input upon receiving a prompt input from RandomSource
                            self.update_graphics.send(((152,251,152), 
                                                       (0, 0, 0), 
                                                       "{}. Press any key!".format(prompt.value)))
                            self.prompt_time = get_physical_time()
                        =}
                        
                        reaction(user_input) -> another {=
                            if self.first:
                                # if the first ever key press is detected, set "another" to trigger a prompt from RandomSource
                                self.first = False
                                self.update_graphics.send(((205,92,92), 
                                                           (0, 0, 0), 
                                                           "Wait for the prompt..."))
                                
                                # ask for the first ever prompt            
                                another.set(42)
                            elif self.prompt_time == 0:
                                if self.count > 0:
                                    self.update_graphics.send(((205,92,92), 
                                                               (0, 0, 0), 
                                                               "YOU CHEATED!", 
                                                               "Average response time: {:.2f} ms".format(self.total_time_in_ms / self.count)))
                                else:
                                    self.update_graphics.send(((205,92,92), 
                                                               (0, 0, 0), 
                                                               "YOU CHEATED!", 
                                                               "Average response time: undefined"))
                                request_stop()
                            else:
                                time_in_ms = (get_logical_time() - self.prompt_time) // MSEC(1)
                                self.update_graphics.send(((205,92,92), 
                                                           (0, 0, 0), 
                                                           "Response time in milliseconds: {}".format(time_in_ms), 
                                                           "Wait for the prompt..."))
                                self.count += 1
                                self.total_time_in_ms += time_in_ms
                                self.prompt_time = 0
                                
                                # ask for another prompt
                                another.set(42)
                        =}
                         
                        reaction(shutdown) {=
                            if self.count > 0:
                                print("Average response time: {:.2f} ms".format(self.total_time_in_ms / self.count))
                            else:
                                print("Average response_time: undefined")
                        =}
                    }
                    
                    /*
                     * Starts the GUI and pass the user_input_pout and 
                     *     update_graphics_pin Pipe objects
                     *     to GetUserInput and UpdateGraphics
                     */
                    reactor StartGui {
                        preamble {=
                            import gui
                        =}
                    
                        output user_input_pipe;
                        output update_graphics_pipe;
                        
                        reaction(startup) -> user_input_pipe, update_graphics_pipe {=
                            # Starts the gui pygame process
                            user_input_pout, update_graphics_pin = self.gui.start_gui()
                            
                            # Sets the outputs to trigger the initialization of GetUserInput and UpdateGrpahics 
                            user_input_pipe.set(user_input_pout)
                            update_graphics_pipe.set(update_graphics_pin)
                        =}
                    }
                    
                    
                    main reactor {
                        random_source = new RandomSource()
                        get_user_input = new GetUserInput()
                        update_graphics = new UpdateGraphics()
                        random_source.out -> update_graphics.prompt
                        get_user_input.user_input -> update_graphics.user_input
                        update_graphics.another -> random_source.another
                        gui = new StartGui()
                        gui.user_input_pipe -> get_user_input.user_input_pipe_init; 
                        gui.update_graphics_pipe -> update_graphics.update_graphics_pipe_init;  
                    }
                    
                    ''')
                addFile("src/gui.py",
                   '''
                   import multiprocessing
                   from multiprocessing import connection
                   import threading
                   import sys
                   import os
                   os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"
                   
                   try:
                       import pygame
                   except:
                        print("Import Error: Failed to import 'pygame'. Try 'pip3 install pygame'")
                        sys.exit(1)
                   
                   
                   def start_gui():
                       # Spawns a new process that runs the pygame gui.
                       # Parameters
                       # ----------
                       # None
                       # Returns
                       # ----------
                       # multiprocessing.connection.PipeConnection
                       #     a Pipe object for the pygame process to send user input to the LF program
                       # multiprocessing.connection.PipeConnection
                       #     a Pipe object for the LF program to send graphics update to the pygame process
                       
                       user_input_pout, user_input_pin = connection.Pipe(duplex=False)
                       update_graphics_pout, update_graphics_pin = connection.Pipe(duplex=False)
                       multiprocessing.set_start_method("spawn")
                       p = multiprocessing.Process(target=gui, args=(user_input_pin, update_graphics_pout))
                       p.start()
                       return user_input_pout, update_graphics_pin
                   
                   
                   def gui(user_input_pin, update_graphics_pout):
                       # Initializes a Gui class and starts the gui.
                       # Parameters
                       # ----------
                       # user_input_pin : multiprocessing.connection.PipeConnection
                       #     a Pipe object for the pygame process to send user input to the LF program
                       # update_graphics_pout : multiprocessing.connection.PipeConnection
                       #     a Pipe object for the LF program to send graphics update to the pygame process
                       # Returns
                       # ----------
                       # None
                       
                       pygame.init()
                       pygame.font.init()
                       g = Gui(user_input_pin=user_input_pin, update_graphics_pout=update_graphics_pout)
                       g.start()
                   
                   
                   class Gui:
                       def __init__(self, user_input_pin, update_graphics_pout):
                           # Initializes the pygame window and spawns a thread to listen for graphics update from the LF program.
                           # Parameters
                           # ----------
                           # user_input_pin : multiprocessing.connection.PipeConnection
                           #     a Pipe object for the pygame process to send user input to the LF program
                           # update_graphics_pout : multiprocessing.connection.PipeConnection
                           #     a Pipe object for the LF program to send graphics update to the pygame process
                           # Returns
                           # ----------
                           # None
                           
                           self.user_input_pin = user_input_pin
                           self.font = pygame.font.SysFont("arial", 18)
                           self.size = self.width, self.height = 500, 500
                           self.terminate = False
                           self.black = 0, 0, 0
                           self.screen = pygame.display.set_mode(self.size)
                           self.listener = threading.Thread(target=self.listen_for_update_graphic, args=(update_graphics_pout, ))
                   
                       def start(self):
                           
                           # Draw the pygame window and listen for user input.
                           # Sends user input to the LF program using self.user_input upon detection.
                           # Parameters
                           # ----------
                           # None
                           # Returns
                           # ----------
                           # None
                           
                           self.screen.fill(self.black)
                           pygame.display.flip()
                           self.listener.daemon = True
                           self.listener.start()
                           try:
                               while 1:
                                   event = pygame.event.wait()
                                   if event.type == pygame.QUIT:
                                       sys.exit(0)
                                   elif event.type == pygame.KEYDOWN:
                                       self.user_input_pin.send(event.unicode)
                           except KeyboardInterrupt:
                               pygame.quit()
                               sys.exit(0)
                   
                       def listen_for_update_graphic(self, update_graphics_pout):
                   
                           # Listens for graphics update from the LF program.
                           # Redraw the pygame window upon receiving graphics update.
                           # Parameters
                           # ----------
                           # update_graphics_pout : multiprocessing.connection.PipeConnection
                           #     a Pipe object for the LF program to send graphics update to the pygame process
                           # Returns
                           # ----------
                           # None
                   
                           while 1:
                               try:
                                   bg_color, text_color, *msg = update_graphics_pout.recv()
                               except EOFError:
                                   pygame.quit()
                                   return
                   
                               self.screen.fill(bg_color)
                               for i, text in enumerate(msg):
                                   text_surface = self.font.render(text, False, text_color)
                                   text_height = text_surface.get_height()
                                   text_rect = text_surface.get_rect(center=(self.width // 2,
                                                                             self.height // 2 + text_height * (0.5 + i - 0.5 * len(msg))))
                                   self.screen.blit(text_surface, text_rect)
                               pygame.display.flip()
                   
                   ''')
            }
            
        ])
    
    }
        
}


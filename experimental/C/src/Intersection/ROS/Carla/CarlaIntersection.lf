/**
 * Model of a smart intersection with a road-side unit (RSU)
 * that regulates the flow of automated vehicles through the
 * intersection. Vehicles that are approaching the intersection
 * send an initial message to the RTU with their speed and
 * distance to the intersection. The RTU responds with a
 * reservation for when the vehicle can enter the intersection
 * and what its average speed through the intersection should be.
 * 
 * This is meant as a supervisory controller, and it assumes that
 * the vehicle is equipped with a low-level controller (or a human)
 * that is responsible for lane keeping, collision avoidance, etc.
 * 
 * This is a very rough starting point that needs a lot of work.
 */
target C {
    threads: 1,
    no-compile: true
};

import Vehicle, RSU from "../IntersectionROS.lf";

preamble {=
    #include <functional>
    #include <memory>
    #include <string>
    #include <iostream>
    #include <unistd.h>
    #include <stdlib.h>

    #include "rclcpp/rclcpp.hpp"
    #include "sensor_msgs/msg/nav_sat_fix.hpp"
    #include "carla_msgs/msg/carla_ego_vehicle_control.hpp"
    #include "carla_msgs/msg/carla_ego_vehicle_status.hpp"
	#include "geometry_msgs/msg/twist.hpp"
	#include "geometry_msgs/msg/vector3.hpp"
=}

reactor Carla (vehicle_name:std::string(""), speed:double(3.0)) {
    preamble {=
        class LFCarlaInterface : public rclcpp::Node {
	        public:
	            LFCarlaInterface(void* status_physical_action,
                    void* gps_physical_action,
                    std::string vehicle_name, 
                    int bank_index
                )
	            : Node("LFCarlaPublisher" + std::to_string(bank_index)), 
	              status_physical_action_(status_physical_action),
	              gps_physical_action_(gps_physical_action),
	              vehicle_name_(vehicle_name),
	              bank_index_(bank_index)
	            {
                    auto target_velocity_topic = "/carla/" + vehicle_name_ + "/control/set_target_velocity";                    
	                publisher_ = this->create_publisher<geometry_msgs::msg::Twist>(target_velocity_topic, 10);
	                RCLCPP_INFO(this->get_logger(), "Vehicle %d: Publishing to: '%s'", 
                        bank_index_ + 1, 
                        target_velocity_topic.c_str()
                    );
                    
                    auto vehicle_status_topic = "/carla/" + vehicle_name_ + "/vehicle_status";
	                status_ = this->create_subscription<carla_msgs::msg::CarlaEgoVehicleStatus>(
                    	vehicle_status_topic , 10, std::bind(&LFCarlaInterface::status_callback, this, std::placeholders::_1));
	                RCLCPP_INFO(this->get_logger(), "Vehicle %d: Subscribing to: '%s'", 
                        bank_index_ + 1, 
                        vehicle_status_topic.c_str()
                    );
                    
                    auto gps_topic = "/carla/" + vehicle_name_ + "/gnss";
                    gps_ = this->create_subscription<sensor_msgs::msg::NavSatFix>(
                    	gps_topic , 10, std::bind(&LFCarlaInterface::gps_callback, this, std::placeholders::_1));
	                RCLCPP_INFO(this->get_logger(), "Vehicle %d: Subscribing to: '%s'", 
                        bank_index_ + 1, 
                        gps_topic.c_str()
                    );
	            }
	            
	            void status_callback(const carla_msgs::msg::CarlaEgoVehicleStatus::SharedPtr msg) const {
                    vehicle_status_t stat = {.velocity = msg->velocity};
        			// info_print("Vehicle %d: Got velocity %.15f", bank_index_ + 1, stat.velocity);
                    schedule_copy(status_physical_action_, 0, &stat, sizeof(stat));
                }
                
                void gps_callback(const sensor_msgs::msg::NavSatFix::SharedPtr msg) const {
                    vehicle_position_t pos;
                    pos.current_pos = (coordinate_t) {.x = msg->latitude, .y = msg->longitude, .z = msg->altitude};
        			// info_print("Vehicle %d: Got velocity %.15f", bank_index_ + 1, stat.velocity);
                    schedule_copy(gps_physical_action_, 0, &pos, sizeof(pos));
                }
	        
	            rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;
	            rclcpp::Subscription<carla_msgs::msg::CarlaEgoVehicleStatus>::SharedPtr status_;
	            rclcpp::Subscription<sensor_msgs::msg::NavSatFix>::SharedPtr gps_;
            	void* status_physical_action_;
            	void* gps_physical_action_;
            	std::string vehicle_name_;
            	int bank_index_;
        }; 
	=}
    physical action vehicle_stat:vehicle_status_t;
    physical action vehicle_pos:vehicle_position_t;
    input command:vehicle_command_t;
    output status:vehicle_status_t;
    output position:vehicle_position_t;
    state lf_carla_interface:{=std::shared_ptr<LFCarlaInterface>=};
    state executor:rclcpp::executors::SingleThreadedExecutor*;
    state context:{=std::shared_ptr<rclcpp::Context>=};
    state simulation_started:bool(false);
    state init_velocity:double(0.0);

    reaction(startup) -> vehicle_stat, vehicle_pos {=
        // Use current time as seed for random generator
        srand(time(0));
        // Set initial velocity
        self->init_velocity = rand() % 4 + 10; 
        
        try {
            rclcpp::init(0, NULL);
        }  catch (...) {
            
        }
        
        self->context = std::make_shared<rclcpp::Context>();
        
        // Check if rclcpp is already initialized
        auto context_name = "LFCarlaInterface" + std::to_string(self->bank_index);
        char *argv[] = {const_cast<char*>(context_name.c_str()), NULL};
        self->context->init(1, argv);
        // Initialize the executor
        rclcpp::executor::ExecutorArgs args;
        args.context = self->context;
        self->executor = new rclcpp::executors::SingleThreadedExecutor(args);
        
        
        // Create the ROS node to facilitate communication between this vehicle and Carla
        self->lf_carla_interface = std::make_shared<LFCarlaInterface>(
            vehicle_stat,
            vehicle_pos,
            self->vehicle_name + "_" + std::to_string(self->bank_index + 1),
            self->bank_index
        );
        self->executor->add_node(self->lf_carla_interface);
        
        // Send it to Carla
        auto message = geometry_msgs::msg::Twist();
		message.linear.x = self->init_velocity;
		info_print("*** Vehicle %d: Setting initial velocity to %.15f.", self->bank_index + 1, message.linear.x);
		// Publish immediately
        self->lf_carla_interface->publisher_->publish(message);
        self->executor->spin_some();
    =}
    reaction(vehicle_stat) -> status {=
        info_print("Vehicle %d: Got velocity %.15f", self->bank_index + 1, vehicle_stat->value.velocity);
        info_print("Vehicle %d: Init velocity %.15f", self->bank_index + 1, self->init_velocity);
        info_print("Vehicle %d: Simulation started %d", self->bank_index + 1, self->simulation_started);
    	// Unfortunately, at the moment, the only feasible way to
		// set initial speeds for the vehicles for the purposes of
		// this simulations seems to be through publishing to ROS.
		// Because of the async nature of ROS, we need to ensure that
		// the initial speed is published and reflected in the simulation
		// before we can accept any vehicle status information from Carla.
        if (!self->simulation_started)  {   
	        if (fabs(vehicle_stat->value.velocity - self->init_velocity) > 1.0f) {
	            // Simulation has not started
	            info_print("Vehicle %d: Simulation not started. Ignoring received velocity.", self->bank_index + 1);
	            // Send the velocity to ROS again because async computing is so stupid
		        auto message = geometry_msgs::msg::Twist();
				message.linear.x = self->init_velocity;
				info_print("*** Vehicle %d: Trying again. Setting initial velocity to %.15f.", self->bank_index + 1, message.linear.x);
				// Publish immediately
		        self->lf_carla_interface->publisher_->publish(message);
		        self->executor->spin_some();
	            return;
	        } else {
                self->simulation_started = true;
            }
        }
        SET(status, vehicle_stat->value);
    =}
    
    reaction(vehicle_pos) -> position {=
    	// Unfortunately, at the moment, the only feasible way to
		// set initial speeds for the vehicles for the purposes of
		// this simulations seems to be through publishing to ROS.
		// Because of the async nature of ROS, we need to ensure that
		// the initial speed is published and reflected in the simulation
		// before we can accept any vehicle status information from Carla.
        if (!self->simulation_started)  { 
	        return;
        }
        SET(position, vehicle_pos->value);
    =}
    reaction(command) {=
        auto message = geometry_msgs::msg::Twist();
		message.linear.x = command->value.x_target_velocity;
		info_print("*** Vehicle %d: Setting velocity to %.15f.", self->bank_index + 1, message.linear.x);
		// Publish immediately
        self->lf_carla_interface->publisher_->publish(message);
        self->executor->spin_some();
    =}
    
    timer t(10 msec, 10 msec);
    reaction(t) {=       
        // rclcpp::spin_some(self->lf_carla_interface);
        self->executor->spin_some();
        // std::cout << "Timer triggered." << std::endl;
    =}
    
   reaction(shutdown) {=
        // std::cout << "Executing shutdown reaction." << std::endl;
    	rclcpp::shutdown();
    =}
}

main reactor (num_entries:int(2)) {
    carla = new[num_entries] Carla(vehicle_name = "ego_vehicle");
    
    vehicles = new[num_entries] Vehicle();    
    rsu = new RSU(num_entries = num_entries, intersection_pos = {=(coordinate_t){-0.00000534,-0.00114776,2.00155615}=});
    
    
    vehicles.request -> rsu.request;
    rsu.grant -> vehicles.grant;
	
    
	vehicles.control -> carla.command;
	carla.status -> vehicles.vehicle_stat;
	carla.position -> vehicles.vehicle_pos;
}

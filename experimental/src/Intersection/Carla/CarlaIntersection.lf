/**
 * Model of a smart intersection with a road-side unit (RSU)
 * that regulates the flow of automated vehicles through the
 * intersection. Vehicles that are approaching the intersection
 * send an initial message to the RTU with their speed and
 * distance to the intersection. The RTU responds with a
 * reservation for when the vehicle can enter the intersection
 * and what its average speed through the intersection should be.
 * 
 * This is meant as a supervisory controller, and it assumes that
 * the vehicle is equipped with a low-level controller (or a human)
 * that is responsible for lane keeping, collision avoidance, etc.
 * 
 * This is a very rough starting point that needs a lot of work.
 */
target C {
    threads: 4,
    no-compile: true
};

import Vehicle, RSU from "../Intersection.lf";

reactor VehicleInterface (num_entries:int(1)) {    
    input[num_entries] from_vehicle:vehicle_status_t;
    output[num_entries] to_vehicle:vehicle_command_t;
    
    vehicles = new[num_entries] Vehicle();    
    rsu = new RSU(num_entries = num_entries);
    
    from_vehicle -> vehicles.vehicle_stat;
    
    vehicles.request -> rsu.request;
    rsu.grant -> vehicles.grant;
	
	vehicles.control -> to_vehicle;
}

reactor Carla {
    preamble {=
	    #include <functional>
	    #include <memory>
	    #include <string>
	    #include <iostream>
	
	    #include "rclcpp/rclcpp.hpp"
	    #include "carla_msgs/msg/carla_ego_vehicle_control.hpp"
	    #include "carla_msgs/msg/carla_ego_vehicle_status.hpp"
		#include "geometry_msgs/msg/twist.hpp"
		#include "geometry_msgs/msg/vector3.hpp"
        class LFCarlaInterface : public rclcpp::Node {
	        public:
	            LFCarlaInterface(void* physical_action)
	            : Node("LFCarlaPublisher"), physical_action_(physical_action)
	            {
	                publisher_ = this->create_publisher<geometry_msgs::msg::Twist>("/carla/ego_vehicle/control/set_target_velocity", 10);
	                subscription_ = this->create_subscription<carla_msgs::msg::CarlaEgoVehicleStatus>(
                    	"/carla/ego_vehicle/vehicle_status", 10, std::bind(&LFCarlaInterface::topic_callback, this, std::placeholders::_1));
	            }
	            
	            void topic_callback(const carla_msgs::msg::CarlaEgoVehicleStatus::SharedPtr msg) const {
                    vehicle_status_t stat = {.velocity = msg->velocity};
        			info_print("Got velocity %f", stat.velocity);
                    schedule_copy(physical_action_, 0, &stat, sizeof(stat));
                }
	        
	            rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;
	            rclcpp::Subscription<carla_msgs::msg::CarlaEgoVehicleStatus>::SharedPtr subscription_;
            	void* physical_action_;
        }; 
	=}
    physical action vehicle_stat:vehicle_status_t;
    input command:vehicle_command_t;
    output status:vehicle_status_t;
    state lf_carla_interface:{=std::shared_ptr<LFCarlaInterface>=};
    reaction(startup) -> vehicle_stat {=
        char *argv[] = {(char*)"LFCarlaInterface", NULL};
        rclcpp::init(1, argv);
        self->lf_carla_interface = std::make_shared<LFCarlaInterface>(vehicle_stat);
        // Give an initial velocity to the vehicle       
    =}
    reaction(vehicle_stat) -> status {=
        SET(status, vehicle_stat->value);
    =}
    reaction(command) {=
        auto message = geometry_msgs::msg::Twist();
		message.linear.x = command->value.x_target_velocity;
		info_print("*** Setting velocity to %f.", message.linear.x);
        self->lf_carla_interface->publisher_->publish(message);
    =}
    
    timer t(0, 10 msec);
    reaction(t) {=       
        rclcpp::spin_some(self->lf_carla_interface);
        // std::cout << "Timer triggered." << std::endl;
    =}
    
   reaction(shutdown) {=
        // std::cout << "Executing shutdown reaction." << std::endl;
    	rclcpp::shutdown();
    =}
}

main reactor (num_entries:int(1)) {
    carla = new[num_entries] Carla();
    vehicleI = new VehicleInterface(num_entries = num_entries);
    
	vehicleI.to_vehicle -> carla.command;
	carla.status -> vehicleI.from_vehicle;
}
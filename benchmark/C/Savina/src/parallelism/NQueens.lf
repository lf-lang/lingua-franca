/**
 * Copyright (C) 2020 TU Dresden and UC Berkeley
 * 
 * This benchmark implements a solution to the N queens problem. In particular,
 * the benchmark implements a recursive search algorithm that finds all possible
 * solution. Given N (size), the board has a size of N x N fields and N queens
 * need to be placed such that no two queens threaten each other.
 * The algorithm starts from an empty board. Then, the first
 * queen is placed on the first line. There are N different options, and in the
 * first operation, all of them are valid. These possible solutions are recorded
 * in a list. In the second iteration, all possible solutions are expanded by
 * adding a second queen to all N positions in the second line. Thereby, each
 * solution is checked for validity and is discarded if invalid. This process
 * continues until the Nth iteration completed and all solutions have been
 * found.
 * 
 * In this benchmark, the workload is distributed across multiple workers. Each
 * worker receives an initial position, and then adds a queen to the next line.
 * The worker sends all valid solutions back to the manager which then again
 * distributes the positions to the workers for further processing. Only for the
 * last `threshold` iterations, the workers directly implement the search to the
 * end and don't produce new work items.
 *
 * This benchmark is very similar to the A* (GuidedSearch) benchmark. An
 * important difference of this LF implementation compared to the Akka
 * implementation is the handling of messages send back from the workers to the
 * manager. In the Akka implementation, each work item produced by the workers is
 * sent as an individual message. This is not easily possible as each port in LF
 * is limited to a single value per tag. Thus, we accumulate multiple work items
 * in a single list, and send this list back to the manager. An alternative
 * solution could use a logical action and call schedule multiple times to defer
 * sending a message. It could be worthwhile to try this out, but it would also
 * complicate the design.
 * 
 * @author Christian Menard
 * @author Hannes Klein
 * @author Arthur Deng
 */

target C{
    /* [[[cog
      if (threaded_runtime=="True"):
          cog.outl(f"threads: {threads},")
      else:
          cog.outl("threads: 0,")
    ]]] */
    /// [[[end]]]
    logging: warn,
    cmake-include: "/lib/c/reactor-c/util/deque.cmake",
    files: ["/lib/c/reactor-c/util/deque.h", "/lib/c/reactor-c/util/deque.c"]
    
};

preamble {=
    #include "deque.h"
    typedef struct work_item_t {
        size_t *data;
        size_t depth;
    } work_item_t;
    
    typedef deque_t work_queue_t;
    
    int i; // declaration for counter used in loops
    
    /**
     * Checks whether the board is a valid configuration of queens where no two queens are on the same 
     * straight or diagonal line.
     */
    int board_valid(size_t n, size_t *a) {
        size_t p = 0, q = 0;
        size_t x = 0, y = 0;
        for (x = 0; x < n; x++) {
            p = a[x];
            for (y = x + 1; y < n; y++) {
                q = a[y];
                if(q == p || q == p - (y - x) || q == p + (y - x)) {
                    return false;
                }
            }
        }
        return true;
    }
    
    /**
     * Function to recursively solve the problem. Called inside the Worker reactor when depth is greater than 
     * or equal to "threshold" (parameter passed in to the benchmark)
     */
    size_t nqueens_kernel_seq(size_t *a, size_t depth, size_t size) {
        if(size == depth) {
            return 1;
        }
        size_t num_solutions = 0;
        size_t *b = (size_t *) malloc (sizeof(size_t) * (depth + 1));
        size_t cnt = 0;
        // recursive calls
        while (cnt < size) {
            size_t idx = 0;
            
            // copy current configuration into new array b and set next row to contain a queen
            // at position "cnt"
            for (idx = 0; idx < depth + 1; idx++) {
                b[idx] = a[idx];
            }
            // set 
            b[depth] = cnt;
            // if new configuration is valid call nqueens_kernel_seq on the new configuration
            if (board_valid(depth + 1, b)) {
                num_solutions += nqueens_kernel_seq(b, depth + 1, size);
            }
            cnt++;
        }
        free(b);
        return num_solutions;
    }
=}

reactor Manager(num_workers: size_t(20), solutions_limit: size_t(1500000), size: size_t(12)) {
    
    state num_solutions: size_t(0);
    state manager_work_queue: {=work_queue_t *=};

    output[num_workers] do_work: work_item_t;
    input[num_workers] solutions_found: size_t;
    input[num_workers] more_work: work_queue_t;
    
    logical action next;
    logical action done;

    reaction (startup) -> do_work, next {=
        self->manager_work_queue = (work_queue_t *) calloc(1, sizeof(struct deque_t)); // freed in shutdown reaction
        
        // set local state
        self->num_solutions = 0;
        
        // start execution
        work_item_t* item = (work_item_t *) calloc(1, sizeof(struct work_item_t)); // freed when item is passed into Worker (line 191)
        
        deque_push_back(self->manager_work_queue, item); 
        
        schedule(next, 0);
    =}

    reaction(done) {=
        // expected solutions for various problem sizes
        size_t solutions[] = {
            1,
            0,
            0,
            2,
            10,     /* 5 */
            4,
            40,
            92,
            352,
            724,    /* 10 */
            2680,
            14200,
            73712,
            365596,
            2279184, /* 15 */
            14772512,
            95815104,
            666090624,
            4968057848,
            39029188884 /* 20 */
        };
        
        // validate the result
        size_t expected = solutions[self->size-1];
        bool valid = self->num_solutions == expected;
        if (self->solutions_limit < expected) {
            valid = self->num_solutions >= self->solutions_limit && self->num_solutions <= expected;
        }
        
        // The validation check above is a corrected version. The original Savina implementation will
        // wrongly mark results as invalid if the solutions limit is above the expected solution.
        printf("Result valid = %d\n", valid);
    =}
    
    reaction (next) -> next, done, do_work {=
        //FIXME: When the benchmark is run, the 20 (= number of Workers) warning messages of freeing already freed token (see below) 
        // is printed every time this reaction happens. 
        //"WARNING: Token being freed that has already been freed: 0x60000011c510"
        
//        DEBUG_PRINT("============================\n"); 
//        printf("%p\n", do_work);
//        printf("%p\n", &self->num_solutions);
//        printf("%p\n", self->manager_work_queue);

        if (deque_is_empty(self->manager_work_queue)) {
            // we are done if there is no more work
            schedule(done, 0);
        } else {
            // send a work item to each worker (until there is no more work)
            for (i = 0; i < self->num_workers && !deque_is_empty(self->manager_work_queue); i++) {
                work_item_t *val = deque_pop_front(self->manager_work_queue);
                SET(do_work[i], *val);
                free(val);
            }
            // and schedule the next iteration
            schedule(next, 0);
        }
    =}
    
    reaction (solutions_found) {=
        // accumulate all the solutions found by looping through solutions_found and increment num_solutions
        size_t s = 0;
        
        for (i = 0; i < self->num_workers; i++) {
            if(solutions_found[i]->is_present) {
                s += solutions_found[i]->value;
            }
        }
        if (s > 0) {
            self->num_solutions += s;
            info_print(" Found %zu solutions; Total solutions %zu\n", s, self->num_solutions);
        }
    =}
    
    reaction (more_work) {=
        // append all work items received from the workers to the internal work queue
        for (i = 0; i < self->num_workers; i++) {
            if(more_work[i]->is_present) {
                work_queue_t items = more_work[i]->value;
                while (!deque_is_empty(&items)) {
                    deque_push_back(self->manager_work_queue, deque_pop_front(&items));
                }
            }
        }
    =}
    reaction (shutdown) {=
        free(self->manager_work_queue);
    =}
}

reactor Worker(bank_index: size_t(0), size: size_t(12), threshold: size_t(4)) {

    input do_work: work_item_t;
    output solutions_found: size_t;
    output more_work: work_queue_t;
    
    reaction(do_work) -> solutions_found, more_work {=
        size_t *a = do_work->value.data;
        size_t depth = do_work->value.depth;
        
        if(self->size == depth) {
            // It is unclear when exactly this evaluates to true and what this means. 
            // However, this seems to be essential for some sizes, including size=1.
            SET(solutions_found, 1);
            // abort the reaction
            return;
        }
        
        if(depth >= self->threshold) {
            // If depth is greater or equal to the threshold, the worker searches for solutions.
            size_t num_solutions = nqueens_kernel_seq(a, depth, self->size);
            if (num_solutions > 0) {
                SET(solutions_found, num_solutions);
            }
        } else {
            // Otherwise, if depth is less than the threshold, the worker splits up the workload and
            // produces new work items.
            size_t newDepth = depth + 1;
            // prepare a work queue to be sent later
            work_queue_t *work_queue = (work_queue_t *) calloc(1, sizeof(struct deque_t)); //freed in Manager (line 225)
            for (i = 0; i < self->size; i++) {
                // prepare a mutable work item
                size_t *vec = (size_t *) calloc(newDepth, sizeof(size_t)); // freed when the work_item_t is handled in another Worker (line 292)
                work_item_t* item = (work_item_t *) calloc(1, sizeof(struct work_item_t)); // freed when popped from manager_work_queue (line 191)
                item->data = vec;
                item->depth = newDepth;
                size_t *b = item->data;
                // copy depth items from a to b
                int j = 0;
                for (j = 0; j < depth; j++) {
                    b[j] = a[j];
                }

                b[depth] = i;
                
                // add the item to the list if is valid
                if(board_valid(newDepth, b)) {
                    deque_push_back(work_queue, item);
                }
            }
            if (!deque_is_empty(work_queue)) {
                SET(more_work, *work_queue);
            }
            free(work_queue);
        }
        
        free(a); // frees memory of current sequence
    =}
}


/* [[[cog
        cog.outl('main reactor (')
        cog.outl(f'size:size_t({size}),')
        cog.outl(f'threshold:size_t({threshold}),')
        cog.outl(f'solutionsLimit:size_t({solutionsLimit}),')
        cog.outl(f'priorities:size_t({priorities}),')
        cog.outl(f'numWorkers:size_t({numWorkers})')
        cog.outl(')')
    ]]] */
main reactor (
    size: size_t(12),
    threshold: size_t(4),
    solutionsLimit: size_t(1500000),
    priorities: size_t(10),
    numWorkers: size_t(20)
) 
/// [[[end]]]
{
    manager = new Manager(num_workers=numWorkers, solutions_limit=solutionsLimit, size=size);
    workers = new[numWorkers] Worker(size=size, threshold=threshold);
    manager.do_work -> workers.do_work;
    workers.solutions_found -> manager.solutions_found;
    workers.more_work -> manager.more_work;    
}

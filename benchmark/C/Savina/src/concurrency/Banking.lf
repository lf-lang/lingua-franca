/*
 * @author: Matt Chorlian
 * @author: Arthur Deng
 */

 /*
Major changes from original C implementation:

- implemented deque for c
- parameter passing for reactor Account: cannot pass in initialBalance = DBL_MAX / (numAccounts * numTransactions)
  when initializing Account. Have to pass in numTransactions and calculate initialBalance in a startup reaction in 
  numAccounts.
  
 */

target C{
    /* [[[cog
      if (threaded_runtime=="True"):
          cog.outl(f"threads: {threads}")
      else:
          cog.outl("threads: 0")
    ]]] */
    threads: 0,
    files: "../include/PseudoRandom.h"
    
    /// [[[end]]]
};
preamble {=
   // #include <../include/PseudoRandom.h>
    #include "PseudoRandom.h"
    #include <float.h>
    long seed = 123456;
    typedef struct CreditMessage {
      size_t recipient;
      double amount;  
    } CreditMessage;
    
    // implementation of c++ deque
    typedef struct node {
        struct node *next;
        struct node *prev;
        struct CreditMessage value;
    } node;
    
    typedef struct deque {
        struct node* front;
        struct node* back;
    } MessageQueue;
    
    MessageQueue* initialize_deque() {
        // allocate space for deque
        struct deque *p = (struct deque *) malloc (sizeof(struct deque));
        if (p != NULL) {
            p->front = NULL;
            p->back = NULL;
        }
        return p;
    }
    
    int isEmpty(struct deque* d) {
        if (d==NULL) {
            return true;
        } else if (d->front) {
            return false;
        }
        return true;
    }
    
    
    node* create_node(struct CreditMessage val) {
        node *new_node = (struct node *) malloc(sizeof(struct node));
        new_node->value = val;
        new_node->next = NULL;
        new_node->prev = NULL;
        return new_node;
    }
    
    void push_front(struct deque* d, struct CreditMessage val) {
        node *n = create_node(val);
        if (d->back == NULL) {
            d->back = d->front = n;
        } else {
            d->front->prev = n;
            n->next = d->front;
            d->front = d->front->prev;
        }
    }
    
    void push_back(struct deque* d, struct CreditMessage val) {
        node *n = create_node(val);
        if (d->back == NULL) {
            d->back = d->front = n;
        } else {
            d->back->next = n;
            n->prev = d->back;
            d->back = d->back->next;
        }
    }

    struct CreditMessage pop_front(struct deque* d) {
        if (d==NULL || d->front == NULL) {
            printf("Error: popping from empty dequeue\n");
            return (CreditMessage) {0, 0};
        }
        
        struct CreditMessage value = d->front->value;
        struct node *temp = d->front; // temporary pointer for freeing up memory
        
        if (d->front == d->back) { 
            // popping last element in dequeue
            d->front = d->back = NULL;
        } else {
            d->front = d->front->next;
        }
        free(temp); // free memory for popped node
        return value;
    }
    
    struct CreditMessage pop_back(struct deque* d) {
        if (d==NULL || d->back == NULL) {
            printf("Error: popping from empty dequeue\n");
            return (CreditMessage) {0, 0};
        }
        
        struct CreditMessage value = d->back->value;
        struct node *temp = d->back; // temporary pointer for freeing up memory
        if (d->front == d->back) { 
            // popping last element in dequeue
            d->front = d->back = NULL;
        } else {
            d->back = d->back->prev;
        }
        free(temp); // free memory for popped node
        return value;
    }
    
    struct CreditMessage peek_back(struct deque* d) {
        if (d == NULL || d->back == NULL) {
            printf("Error: peeking empty dequeue");
            return (CreditMessage) {0, 0};
        }
        return d->back->value;
    }
    
    struct CreditMessage peek_front(struct deque* d) {
        if (d == NULL || d->front == NULL) {
            printf("Error: peeking empty dequeue");
            return (CreditMessage) {0, 0};
        }
        return d->front->value;
    }
=}


reactor Teller(numAccounts:int(1000), numBankings:int(50000)) {
    preamble {=
        struct PseudoRandom *randomGen;
    =}

    state messageQueues: MessageQueue*;

    reaction(startup) {=
        self->messageQueues = (MessageQueue *) calloc(self->numAccounts, sizeof(MessageQueue));
        randomGen = (struct PseudoRandom *) malloc(sizeof(struct PseudoRandom));
        initPseudoRandom(randomGen, seed);
    =}

    input start:bool;
    output finished:bool;
    
    output[numAccounts] reset: bool; 
    output[numAccounts] credit: CreditMessage;
    
    logical action next;
    
    reaction(start) -> reset, next {=
        printf("Teller: Start a new iteration\n");
        
        // reset local state
        long seed = 123456;
        
        // reset all accounts
        int i;
        for (i = 0; i < self->numAccounts; i++) {
            SET(reset[i], true);
        }
            
        // generateWork();
        for (i = 0; i < self->numBankings; i++) {
            // src is lower than dest id to ensure there is never a deadlock
            // Note: this comment stems from the original Akka implementation and 
            // is actually not needed in LF, since cycle free programs cannot deadlock
            size_t src_account = nextIntEMax(randomGen, (self->numAccounts / 10) * 8);
            size_t loop_id = nextIntEMax(randomGen, self->numAccounts - src_account);
            if(loop_id == 0) {
                loop_id += 1;
            }
            size_t dest_account = src_account + loop_id;
            
            double amount = nextDouble(randomGen);
            
            CreditMessage newMsg;
            newMsg.recipient = dest_account;
            newMsg.amount = amount;
            push_back(&(self->messageQueues[src_account]), newMsg);
        }
                
        // start execution
        schedule(next, 0);
    =}
    
    reaction(next) -> next, credit, finished {=
        printf("Teller: Sending a new round of credit messages\n");
        //        bool work_found(false);
        int work_found = 0;
        size_t i;
        for (i = 0; i < self->numAccounts; i++) {
            MessageQueue *queue = &(self->messageQueues[i]);
            if (!isEmpty(queue)) {
                work_found = 1;
                CreditMessage message = peek_front(queue);  
                SET(credit[message.recipient], message);
                pop_front(queue);
            }
        }
        
        if (work_found) {
            schedule(next, 0);
        } else {
            printf("Teller: Finished iteration\n");
            SET(finished, true);
        }
    =}
    reaction(shutdown) {=
        free(self->messageQueues);
        free(randomGen);
        printf("shutdown success\n");
    =}
    
}

reactor Account(bank_index:size_t(0), numAccounts:size_t(1000), numTransactions:size_t(50000)) {
    
    state balance: double(0);
    state initialBalance: double(0);
    input reset: bool; 
    input inCredit: CreditMessage;
   
    input[numAccounts] inDebit: double; 
    output[numAccounts] outDebit: double;
    
    reaction (startup) {=
        self->initialBalance = DBL_MAX / (self->numAccounts * self->numTransactions);
    =}

    reaction (reset) {=
        self->balance = self->initialBalance;
    =}
    
    reaction (inCredit) -> outDebit {=
        CreditMessage message = inCredit->value; 
        // reduce the balance
        self->balance -= message.amount;
        // and sent the recipient a debit message
        SET(outDebit[message.recipient], message.amount);
        printf("Account %zu credits %f to %zu\n", self->bank_index, message.amount, message.recipient);
    =}
    
    reaction (inDebit) {=
        int i;
        for (i = 0; i<self->numAccounts;i++) {
            if (inDebit[i]->is_present) {
                double amount = inDebit[i]->value;
                // increase the balance
                self->balance += amount;
                printf("Account: %zu received %f\n", self->bank_index, amount);         
            }
        }
    =}
}
// FIXME default value of numAccounts should be 1000.
// Increasing the accounts to 1000 is currently not possible as Epoch would crash (see #433)

/* [[[cog
        cog.outl(f'main reactor (numTransactions:int({numTransactions}), numAccounts:int({numAccounts}))')
    ]]] */
    main reactor (numTransactions:int(50000), numAccounts:int(20)) 
    /// [[[end]]]
{    
    teller = new Teller(numAccounts=numAccounts, numBankings=numTransactions);
    
    accounts = new[numAccounts] Account(numAccounts=numAccounts, numTransactions=numTransactions);
    reaction(startup) -> teller.start {=
        struct PseudoRandom randomGen;
        initPseudoRandom(&randomGen, seed);
        SET(teller.start, true);
    =}
    
    teller.credit -> accounts.inCredit;
    teller.reset -> accounts.reset;
    accounts.outDebit -> interleaved(accounts.inDebit);
}
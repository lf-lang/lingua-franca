/**
 * Copyright (C) 2020 TU Dresden
 * 
 * This benchmark consists of a so-called 'Teller' and a number of Account reactors.
 * The Accounts keep an internal balance. The Teller generates a series of random 
 * credit messages which it sends to the various accounts. Each credit message
 * specifies an amount and a destination account. The account that receives a credit
 * message from the teller will reduce its balance by the given amount and sends a 
 * debit message of the same amount to the destination account. The destination 
 * account will then increase its balance accordingly.
 * 
 * Note that the original Akka implementation performs an explicit synchronisation, to
 * ensure that the debit message has been processed by the destination account before
 * replying to the teller that the credit message was processed. This synchronization
 * and reply mechanism is not required in LF, as all messages are processed logically
 * synchronous. The teller can be sure that any credit messages it sends will be 
 * processed before moving to the next tag, and similarly each account can be sure that
 * any debit messages it sends will be processed by the receiving accounts before
 * receiving any new messages.
 * 
 * The initial generation of all the credit messages is an interesting problem in LF.
 * In the Akka implementation, the teller actor will just send `numBankings` randomly 
 * generated messages to the account actors, which then process one message after the 
 * other. However, this is not easily doable in LF, as a port can only hold a single 
 * value. In order to send multiple messages to the same account, the teller needs to
 * use an action and advance in logical time before sending the next message. This is
 * currently implemented such that the Teller creates an initial queue per account
 * which contains all credit messages that should be sent to this account. Then it 
 * schedules it `next` action and the corresponding reaction will send the first 
 * round of messages to the accounts. Then it schedules next again. This continues
 * until all messages are sent.
 * 
 * A potential optimization to the problem described above, would be not to send
 * individual credit messages to the accounts, but instead a list of messages (for
 * instance a std::vector). This could be done in a single logical step and should
 * thus be much faster. However, this is likely an unfair advantage over the Akka 
 * implementation, which also sends all messages individually.
 * 
 * @author Hannes Klein
 * @author Christian Menard
 * @author: Matt Chorlian
 * @author: Arthur Deng
 *
 * Major changes from original Cpp implementation:
 *     - implemented deque for c
 *     - parameter passing for reactor Account: cannot pass in initialBalance = DBL_MAX / (numAccounts * numTransactions)
 *   when initializing Account. Have to pass in numTransactions and calculate initialBalance in a startup reaction in 
 *   numAccounts.
 */


target C{
    /* [[[cog
      if (threaded_runtime=="True"):
          cog.outl(f"threads: {threads}")
      else:
          cog.outl("threads: 0")
    ]]] */
    threads: 0,
    files: "../include/PseudoRandom.h"
    
    /// [[[end]]]
};
preamble {=
    #include "PseudoRandom.h"
    #include <float.h>
    long seed = 123456;

    typedef struct CreditMessage {
      size_t recipient;
      double amount;  
    } credit_message_t;
    
    // implementation of c++ deque
    typedef struct node {
        struct node *next;
        struct node *prev;
        credit_message_t value;
    } node;
    
    typedef struct deque {
        struct node* front;
        struct node* back;
    } message_queue_t;
    
    message_queue_t* deque_initialize() {
        // allocate space for deque
        message_queue_t *p = (message_queue_t *) malloc (sizeof(message_queue_t));
        if (p != NULL) {
            p->front = NULL;
            p->back = NULL;
        }
        return p;
    }
    
    int deque_is_empty(struct deque* d) {
        if (d==NULL) {
            return true;
        } else if (d->front) {
            return false;
        }
        return true;
    }
    
    
    node* _deque_create_node(credit_message_t val) {
    /*
    * Function:  _deque_create_node
    * --------------------
    * allocates memory for new node in deque. Used internally by deque_push_front
    * and deque_push_back. Memory is freed when node is popped using deque_pop_back
    * and deque_pop_front.
    *
    *  val: value to be stored in the node
    *
    *  returns: pointer to the node

    */
        node *new_node = (struct node *) malloc(sizeof(struct node));
        new_node->value = val;
        new_node->next = NULL;
        new_node->prev = NULL;
        return new_node;
    }
    
    void deque_push_front(struct deque* d, credit_message_t val) {
        node *n = _deque_create_node(val);
        if (d->back == NULL) {
            d->back = d->front = n;
        } else {
            d->front->prev = n;
            n->next = d->front;
            d->front = d->front->prev;
        }
    }
    
    void deque_push_back(struct deque* d, credit_message_t val) {
        node *n = _deque_create_node(val);
        if (d->back == NULL) {
            d->back = d->front = n;
        } else {
            d->back->next = n;
            n->prev = d->back;
            d->back = d->back->next;
        }
    }

    credit_message_t deque_pop_front(struct deque* d) {
        if (d==NULL || d->front == NULL) {
            fprintf(stderr, "Error: popping from empty deque\n");
            return (credit_message_t) {0, 0};
        }
        
        credit_message_t value = d->front->value;
        struct node *temp = d->front; // temporary pointer for freeing up memory
        
        if (d->front == d->back) { 
            // popping last element in deque
            d->front = d->back = NULL;
        } else {
            d->front = d->front->next;
        }
        free(temp); // free memory for popped node
        return value;
    }
    
    credit_message_t deque_pop_back(struct deque* d) {
        if (d==NULL || d->back == NULL) {
            fprintf(stderr, "Error: popping from empty deque\n");
            return (credit_message_t) {0, 0};
        }
        
        credit_message_t value = d->back->value;
        struct node *temp = d->back; // temporary pointer for freeing up memory
        if (d->front == d->back) { 
            // popping last element in deque
            d->front = d->back = NULL;
        } else {
            d->back = d->back->prev;
        }
        free(temp); 
        return value;
    }
    
    credit_message_t deque_peek_back(struct deque* d) {
        if (d == NULL || d->back == NULL) {
            fprintf(stderr, "Error: peeking empty deque");
            return (credit_message_t) {0, 0};
        }
        return d->back->value;
    }
    
    credit_message_t deque_peek_front(struct deque* d) {
        if (d == NULL || d->front == NULL) {
            fprintf(stderr, "Error: peeking empty deque");
            return (credit_message_t) {0, 0};
        }
        return d->front->value;
    }
=}


reactor Teller(numAccounts:int(1000), numBankings:int(50000)) {
    preamble {=
        struct PseudoRandom *randomGen;
    =}

    state messageQueues: message_queue_t*;

    reaction(startup) {=
        self->messageQueues = (message_queue_t *) calloc(self->numAccounts, sizeof(message_queue_t));
        randomGen = (struct PseudoRandom *) malloc(sizeof(struct PseudoRandom));
        initPseudoRandom(randomGen, seed);
    =}

    input start:bool;
    output finished:bool;
    
    output[numAccounts] reset: bool; 
    output[numAccounts] credit: credit_message_t;
    
    logical action next;
    
    reaction(start) -> reset, next {=
        printf("Teller: Start a new iteration\n");
        
        // reset local state
        long seed = 123456;
        
        // reset all accounts
        int i;
        for (i = 0; i < self->numAccounts; i++) {
            SET(reset[i], true);
        }
            
        // generateWork();
        for (i = 0; i < self->numBankings; i++) {
            // src is lower than dest id to ensure there is never a deadlock
            // Note: this comment stems from the original Akka implementation and 
            // is actually not needed in LF, since cycle free programs cannot deadlock
            size_t src_account = nextIntEMax(randomGen, (self->numAccounts / 10) * 8);
            size_t loop_id = nextIntEMax(randomGen, self->numAccounts - src_account);
            if(loop_id == 0) {
                loop_id += 1;
            }
            size_t dest_account = src_account + loop_id;
            
            double amount = nextDouble(randomGen);
            
            credit_message_t newMsg;
            newMsg.recipient = dest_account;
            newMsg.amount = amount;
            deque_push_back(&(self->messageQueues[src_account]), newMsg);
        }
                
        // start execution
        schedule(next, 0);
    =}
    
    reaction(next) -> next, credit, finished {=
        printf("Teller: Sending a new round of credit messages\n");
        //        bool work_found(false);
        int work_found = 0;
        size_t i;
        for (i = 0; i < self->numAccounts; i++) {
            message_queue_t *queue = &(self->messageQueues[i]);
            if (!deque_is_empty(queue)) {
                work_found = 1;
                credit_message_t message = deque_peek_front(queue);  
                SET(credit[message.recipient], message);
                deque_pop_front(queue);
            }
        }
        
        if (work_found) {
            schedule(next, 0);
        } else {
            printf("Teller: Finished iteration\n");
            SET(finished, true);
        }
    =}
    reaction(shutdown) {=
        free(self->messageQueues);
        free(randomGen);
        printf("shutdown success\n");
    =}
    
}

reactor Account(bank_index:size_t(0), numAccounts:size_t(1000), numTransactions:size_t(50000)) {
    
    state balance: double(0);
    state initialBalance: double(0);
    input reset: bool; 
    input inCredit: credit_message_t;
   
    input[numAccounts] inDebit: double; 
    output[numAccounts] outDebit: double;
    
    reaction (startup) {=
        self->initialBalance = DBL_MAX / (self->numAccounts * self->numTransactions);
    =}

    reaction (reset) {=
        self->balance = self->initialBalance;
    =}
    
    reaction (inCredit) -> outDebit {=
        credit_message_t message = inCredit->value; 
        // reduce the balance
        self->balance -= message.amount;
        // and sent the recipient a debit message
        SET(outDebit[message.recipient], message.amount);
        printf("Account %zu credits %f to %zu\n", self->bank_index, message.amount, message.recipient);
    =}
    
    reaction (inDebit) {=
        int i;
        for (i = 0; i<self->numAccounts;i++) {
            if (inDebit[i]->is_present) {
                double amount = inDebit[i]->value;
                // increase the balance
                self->balance += amount;
                printf("Account: %zu received %f\n", self->bank_index, amount);         
            }
        }
    =}
}
// FIXME default value of numAccounts should be 1000.
// Increasing the accounts to 1000 is currently not possible as Epoch would crash (see #433)

/* [[[cog
        cog.outl(f'main reactor (numTransactions:int({numTransactions}), numAccounts:int({numAccounts}))')
    ]]] */
    main reactor (numTransactions:int(50000), numAccounts:int(20)) 
    /// [[[end]]]
{    
    teller = new Teller(numAccounts=numAccounts, numBankings=numTransactions);
    
    accounts = new[numAccounts] Account(numAccounts=numAccounts, numTransactions=numTransactions);
    reaction(startup) -> teller.start {=
        struct PseudoRandom randomGen;
        initPseudoRandom(&randomGen, seed);
        SET(teller.start, true);
    =}
    
    teller.credit -> accounts.inCredit;
    teller.reset -> accounts.reset;
    accounts.outDebit -> interleaved(accounts.inDebit);
}
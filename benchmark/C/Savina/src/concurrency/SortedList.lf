/**
 * Copyright (C) 2020 TU Dresden and UC Berkeley
 *
 * Upon startup, the LinkedList actor initializes a
 * linked list with random elements. Upon startup the
 * Worker actors would send either a `read` or `write`
 * request to the LinkedList, which responds by sending
 * a `response` signal. When Workers receive this signal,
 * if they've hit their target requests amount they will
 * send a `finish` message; otherwise, they will continue
 * to query the LinkList.
 *
 * @author Thee Ho
 * @author Matt Chorlian
 */

target CCpp {
    /* [[[cog
      if (threading=="True"):
          cog.outl("threading: true,")
          cog.outl(f"workers: {workers},")
          cog.outl(f"scheduler: {scheduler},")
      else:
          cog.outl("threading: false,")
    ]]] */
    threading: false,
    /// [[[end]]]
    files: "../include/PseudoRandom.h"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

preamble {=
    typedef enum {
        WRITE,
        SIZE,
        CONTAINS
    } access_type;
    
    typedef struct message_t {
        access_type type;
        int value;
    } message_t;
=}

reactor Manager(numWorkers: size_t(20)) {
    // The C++ version of this benchmark requires this reactor for communication with
    // the benchmark runner. In this C version, it is less important.
    
    state num_workers_terminated: size_t(0);

    input start:bool;
    output finished: bool;
    
    input[numWorkers] workers_finished: bool;

    logical action finish;

    reaction(finish) -> finished {=
        SET(finished, true);
    =}
    
    reaction(workers_finished) -> finish {=
        for (size_t i = 0; i < self->numWorkers; ++i) {
            if (workers_finished[i]->is_present) {
                self->num_workers_terminated += 1;
                
                if (self->num_workers_terminated == self->numWorkers) {
                    schedule(finish, 0);
                }
            }
        }
    =}

    reaction(start) {=
      self->num_workers_terminated = 0;
    =}
}

reactor Worker(
    bank_index: int(0),
    num_requests: int(8000),
    write_percentage: int(10),
    size_percentage: int(1)
) {

    preamble {=
        #include "PseudoRandom.h"
    =}

    input response: int;
    
    state requests_sent: int(0);
    state random: PseudoRandom;

    input doWork: bool;
    output finished: bool;
    
    output request: message_t;

    reaction(doWork, response) -> request, finished {=

        if (doWork->is_present) {
          initPseudoRandom(
              &self->random,
              self->bank_index
                  + self->num_requests
                  + self->write_percentage
                  + self->size_percentage
          );
        }
          
        if (self->requests_sent < self->num_requests) {
            int coin = nextIntEMax(&self->random, 100);
            message_t message;
            if (coin < self->write_percentage) {
                message = (message_t) { .type=WRITE, .value=nextInt(&self->random) };
            } else if (coin < (self->write_percentage + self->size_percentage)) {
                message = (message_t) { .type=SIZE, .value=-1 };
            } else {
                message = (message_t) { .type=CONTAINS, .value=nextInt(&self->random) };
            }
            SET(request, message);
            self->requests_sent++;
        } else {
            SET(finished, true);
            self->requests_sent = 0;
        }
    =}
}

reactor LinkedList(num_workers: int(20)) {
    
    state data_list: {=SortedLinkedList<int>*=};
    state responses_to_send: int[];

    logical action send_responses;
    
    input finished: bool;
    input[num_workers] requests: message_t;
    output[num_workers] responses: int;
    
    reaction(startup) {=
        self->data_list = new SortedLinkedList<int>();
        self->responses_to_send = (int*) malloc(self->num_workers * sizeof(int));
    =}

    reaction(finished) {=
        // check result
        info_print("List Size = %d", self->data_list->size());
        // reset local state
        delete self->data_list;
        self->data_list = new SortedLinkedList<int>();
    =}

    reaction(send_responses) -> responses {=
        for (size_t i = 0; i < self->num_workers; i++) {
            SET(responses[i], self->responses_to_send[i]);
            LOG_PRINT("Reply to worker %d with %d", self->responses_to_send[i]);
        }
    =}

    reaction(requests) -> send_responses {=
        schedule(send_responses, 0);

        for (size_t i = 0; i < self->num_workers; i++) {
            int value = requests[i]->value.value;
            switch (requests[i]->value.type) {
                case CONTAINS:
                    self->responses_to_send[i] = self->data_list->contains(value);
                    LOG_PRINT(
                        "Worker %ld checks if %d is contained in the list",
                        i, value
                    );
                    break;
                case WRITE:
                    self->data_list->add(value);
                    self->responses_to_send[i] = value;
                    LOG_PRINT("Worker %ld writes %d", i, value);
                    break;
                case SIZE:
                    self->responses_to_send[i] = self->data_list->size();
                    LOG_PRINT("Worker %ld reads the list size", i);
                    break;
            }
        }
    =}

    reaction (shutdown) {=
        free(self->responses_to_send);
    =}

    preamble {=
        #include <bitset>
        #include <vector>
        /**
         * Copied directly from the C++ implementation of this benchmark.
         * Based on: http://www.cs.ucsb.edu/~franklin/20/assigns/prog2files/MySortedLinkedList.java
         */
        
        template <typename T>
        class SortedLinkedList {
        private:
          /**
           * stores a single item in the linked list
           */
          template <typename U>
          class Node {
          public:
            U item;
            Node<U>* next;
        
            Node(const U& i) {
              item = i;
              next = nullptr;
            }
          };
        
          // a reference to the first node in the list
          Node<T>* head;
          // a reference to the node to return when next() is called
          Node<T>* iterator;
        public:
          /**
           * constructor creates a linked list with no items in it
           */
          SortedLinkedList() {
            head = nullptr;
            iterator = nullptr;
          }
        
          ~SortedLinkedList() {
            std::vector<Node<T>*> elementsToDelete;
        
            Node<T>* n = head;
            while (n != nullptr) {
              elementsToDelete.push_back(n);
              n = n->next;
            }
        
            for(auto el: elementsToDelete) {
              delete el;
            }
          }
        
          /**
           * isEmpty inputs: none return value: returns true if there are no items in linked list
           */
           bool isEmpty() {
             return (head == nullptr);
           }
        
           /**
            * add inputs: Comparable item return value: none adds an item into the list in sorted order
            */
           void add(const T& item) {
             // make the new node to insert into list
             Node<T>* newNode = new Node(item);
             // first see if the list is empty
             if (head == nullptr) {
               // std::cout << "add " << item << " to front";
               head = newNode;
             } else if (item < head->item) {
               // there is something in the list
               // now check to see if it belongs in front
               // System.out.println("add "+item +"before"+head.item);
               newNode->next = head;
               head = newNode;
             } else {
               // otherwise, step down the list.  n will stop
               // at the node after the new node, and trailer will
               // stop at the node before the new node
               Node<T>* after = head->next;
               Node<T>* before = head;
               while (after != nullptr) {
                 if (item < after->item) {
                   break;
                 }
                 before = after;
                 after = after->next;
               }
               // insert between before & after
               newNode->next = before->next;
               before->next = newNode;
               // std::cout << "add " << item << "after" << before->item;
             }
           }
        
           /* contains
            * inputs: Comparable item
            * return value: true if equal item is in list, false otherwise
            */
           bool contains(const T& item) const {
             Node<T>* n = head;
             // for each node in the linked list
             while(n != nullptr) {
               // if it is equal, return true
               // note that I used compareTo here, not equals
               // because I am only guaranteed that the
               // compareTo method is implemented, not equals
               if(item == n->item) {
                 return true;
               }
               n = n->next;
             }
             // if it is not found in list, return false
             return false;
           }
        
           template <typename U>
           friend std::ostream& operator<<(std::ostream&, SortedLinkedList&);
        
           /**
            * next inputs: none return value: one element from the linked list This method returns each element in the linked
            * list in order. It is to be used in a loop to access every item in the list.
            */
           T* next() {
             if (iterator != nullptr) {
               Node<T>* n = iterator;
               iterator = iterator->next;
               return n->item;
             } else {
               return nullptr;
             }
           }
        
           /**
            * reset inputs: none return value: none resets the iterator so that the next call to next() will return the first
            * element in the list
            */
           void reset() {
             iterator = head;
           }
        
           /**
            * size inputs: none return value: the number of elements in linked list
            */
           int size() {
             int r = 0;
             Node<T>* n = head;
             // for each node in the linked list
             while (n != nullptr) {
               r++;
               n = n->next;
             }
             return r;
           }
        };
        
        /**
         * toString inputs: none return value: string representation of the linked list items Format must match assignment
         */
        template <typename T>
        std::ostream& operator<<(std::ostream& strm, SortedLinkedList<T>& a) {
          auto n = a.head;
          while(n != nullptr) {
            strm << n->item;
            n = n->next;
          }
          return strm;
        }
    =}
}

/* [[[cog
      cog.outl(f'main reactor(numIterations:int({numIterations}), numWorkers:int({numWorkers}),numMessagesPerWorker:int({numMessagesPerWorker}),writePercentage:int({writePercentage}), sizePercentage:int({sizePercentage}))')
    ]]] */
main reactor(numIterations:int(12), numWorkers:int(20), numMessagesPerWorker:int(8000), writePercentage:int(10), sizePercentage:int(1))
    // [[[end]]]
{
    manager = new Manager(numWorkers=numWorkers);
    workers = new[numWorkers] Worker(
        num_requests=numMessagesPerWorker,
        write_percentage=writePercentage,
        size_percentage=sizePercentage
    );

    runner = new BenchmarkRunner(num_iterations=numIterations);
    sorted_list = new LinkedList(num_workers=numWorkers);

    (runner.start)+ -> manager.start, workers.doWork;
    manager.finished -> runner.finish;
    manager.finished -> sorted_list.finished;
    
    workers.request -> sorted_list.requests;
    sorted_list.responses -> workers.response;
    workers.finished -> manager.workers_finished;
}

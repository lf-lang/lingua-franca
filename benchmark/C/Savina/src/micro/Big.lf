/**
 * A benchmark that implements a many-to-many message passing scenario. Several
 * workers are created, each of which sends a ping message to one other worker.
 * To which worker the ping message is sent is decided randomly. The worker
 * who receives the ping message replies with a pong. Uppon receiving the pong,
 * the worker sends the next ping message.
 *
 * In LF, the challenging aspect about this benchmark is its sparse activity.
 * While each worker is connected to all other workers, it will only send a
 * message to precisely one of them for each tag. Since we need to ensure that
 * input ports have a single writer, each worker has to create multiport inputs,
 * where each port instance corresponds to one potential source of ping or pong
 * messages. In order to determine from which worker we received a ping or pong
 * message, we need to iterate over all ports and check `if_present()`. However,
 * this becomes very expensive for a large number of workers. For 120 workers we
 * send a total of 120 pings and 120 pongs per iteration, but we need to check
 * up to 14400 ping ports and 14400 pong ports in each iteration. Obviously this
 * introduces a large overhead.
 *
 * @author Hannes Klein
 * @author Felix Wittwer
 * @author Christian Menard
 * @author Arthur Deng
 */



target C{
    /* [[[cog
      if (threaded_runtime=="True"):
          cog.outl(f"threads: {threads},")
      else:
          cog.outl("threads: 0,")
    ]]] */  
    /// [[[end]]]
    files: "../include/PseudoRandom.h"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

// Despite the name, this only collects "finished" messages from all workers
// and lets the benchmark runner know when all the workers finished
reactor Sink(num_workers:size_t(10)) {
    // number of exit messages received
    input start:bool;
    state num_messages: size_t(0);
    input[num_workers] worker_finished :bool;
    output finished: bool;
    reaction(start) {=
        // reset state
        self->num_messages = 0;
    =}
    
    reaction(worker_finished) -> finished {=
        // collect all exit messages, finish when all the messages have been received.
        int i;
        for(i = 0; i < self->num_workers; i++) {
            if(worker_finished[i]->is_present) {
                self->num_messages += 1;
                if(self->num_messages == self->num_workers) {
                    SET(finished, true);
                }
            }
        }
    =}
}

reactor Worker(bank_index: size_t(0), num_messages: size_t(20000), num_workers:size_t(10)) {
    
    preamble {=
        #include "PseudoRandom.h"
        #include "stdint.h"
    =}
    
    state num_pings: size_t(0);
    state random: PseudoRandom;
    state exp_pong: size_t({=SIZE_MAX=});
    
    input start:bool;
    input[num_workers] in_ping: bool;
    input[num_workers] in_pong: bool;
    output[num_workers] out_ping: bool;
    output[num_workers] out_pong: bool;
    output finished : bool;
    logical action next;
    
    // send ping
    reaction (next) -> out_ping {=
        self->num_pings++;
        int to = nextInt(&(self->random)) % self->num_workers; 
        self->exp_pong = to;
        SET(out_ping[to], true);
    =}
    
    // reply with pong
    reaction(in_ping) -> out_pong {=
        size_t i;
        for(i = 0; i < self->num_workers; i++) {
            if (in_ping[i]->is_present) { 
                SET(out_pong[i], true);
            }
        }
    =}
    
    // receive pong and send next ping
    reaction (in_pong) -> next, finished {=
        size_t i;
        for(i = 0; i < self->num_workers; i++) {
            if (in_pong[i]->is_present) {
                if (i != self->exp_pong) {
                    fprintf(stderr, "Expected pong from %zu but received pong from %zu", self->exp_pong, i);
                }
            }
        }
        
        // send next ping
        if (self->num_pings == self->num_messages) {
            SET(finished, true);
        } else {
            schedule(next, 0);
        }
    =}
    
    reaction (start) -> next {=
        // reset state
        self->num_pings = 0;
        self->exp_pong = SIZE_MAX;
        initPseudoRandom(&(self->random), self->bank_index);
        
        // start execution
        schedule(next, 0);
    =}
}

/* [[[cog
    cog.outl(f'main reactor (numIterations:int(12), numPingsPerReactor:int({numPingsPerReactor}), numReactors:int({numReactors}))')
]]] */
main reactor (numIterations:int(12), numPingsPerReactor:size_t(20000), numReactors:size_t(120)) 
/// [[[end]]]
{
    
    runner = new BenchmarkRunner(num_iterations=numIterations);
    sink = new Sink(num_workers=numReactors);
    worker = new[numReactors] Worker(num_messages=numPingsPerReactor, num_workers=numReactors);

    reaction (startup) -> runner.inStart {=
        printBenchmarkInfo("BigReactorLFCBenchmark");
        printSystemInfo();
    =}

    (runner.start)+ -> sink.start, worker.start;
    worker.finished -> sink.worker_finished;
    sink.finished -> runner.finished;
    
    worker.out_ping -> interleaved(worker.in_ping);    
    worker.out_pong -> interleaved(worker.in_pong);
}
